<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>제미나이 디펜스</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Jua&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Jua', sans-serif;
            touch-action: none; /* 모바일에서 더블탭 확대 방지 */
            overflow: hidden;
            background-color: #0c1427;
        }
        /* 커스텀 스크롤바 (필요시) */
        ::-webkit-scrollbar { width: 4px; }
        ::-webkit-scrollbar-track { background: #1e293b; }
        ::-webkit-scrollbar-thumb { background: #475569; border-radius: 2px; }

        .hud-item {
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(100, 116, 139, 0.5);
        }
        .tower-slot.highlight {
             box-shadow: 0 0 20px #facc15;
             border-radius: 50%;
        }
        .tower-button.selected {
            background-color: #0e7490;
            box-shadow: 0 0 15px #06b6d4;
            transform: scale(1.05);
        }
        .tab-button.active {
            color: #06b6d4;
            border-color: #06b6d4;
        }
        .tower-button.locked .lock-overlay {
            display: flex;
        }
        .tower-button:not(.locked) .lock-overlay {
            display: none;
        }
        .tower-button .tooltip {
            display: none;
            pointer-events: none; /* 툴팁이 마우스 이벤트를 가로채지 않도록 설정 */
        }
        .tower-button:hover .tooltip {
            display: block;
        }

        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 0.7; }
            70% { transform: translate(-50%, -50%) scale(1.4); opacity: 0; }
            100% { transform: translate(-50%, -50%) scale(1.4); opacity: 0; }
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .fade-in {
            animation: fadeIn 0.5s ease-out forwards;
        }
    </style>
</head>
<body class="flex flex-col h-screen text-white p-2">

    <!-- 게임 UI 컨테이너 -->
    <div id="game-container" class="flex flex-col h-full w-full max-w-md mx-auto bg-[#16223b] rounded-xl shadow-2xl overflow-hidden border-2 border-slate-700 relative">

        <!-- 상단 HUD -->
        <div id="hud" class="grid grid-cols-3 gap-2 p-2 text-center">
            <div class="hud-item rounded-lg p-2">
                <span class="text-2xl">❤️</span>
                <span id="health" class="text-xl font-bold">20</span>
            </div>
            <div class="hud-item rounded-lg p-2">
                <span class="text-2xl">💰</span>
                <span id="resources" class="text-xl font-bold">150</span>
            </div>
            <div class="hud-item rounded-lg p-2">
                <span class="text-2xl">🌊</span>
                <span id="wave" class="text-xl font-bold">0 / 10</span>
            </div>
        </div>
        
        <!-- 게임 캔버스 -->
        <div id="canvas-container" class="flex-1 relative">
            <canvas id="gameCanvas" class="absolute top-0 left-0 w-full h-full"></canvas>
        </div>

        <!-- 하단 컨트롤 패널 -->
        <div id="controls" class="p-2 bg-black bg-opacity-30 flex flex-col">
            <!-- 탭 버튼 -->
            <div class="flex mb-2 border-b border-slate-700">
                <button data-tab="build" class="tab-button flex-1 pb-2 text-lg font-bold border-b-2 transition-colors active">건설</button>
                <button data-tab="activity" class="tab-button flex-1 pb-2 text-lg font-bold border-b-2 border-transparent text-slate-400 transition-colors">활동</button>
            </div>
            
            <!-- 탭 패널 (고정 높이 적용) -->
            <div id="tab-panels" class="relative h-40">
                <!-- 건설/관리 패널 -->
                <div id="panel-build" class="tab-panel absolute inset-0 overflow-y-auto">
                    <!-- 타워 선택 UI -->
                    <div id="tower-selection-ui">
                        <p class="text-center text-sm text-slate-400 mb-2">건설할 타워를 선택하세요</p>
                        <div id="tower-buttons" class="grid grid-cols-4 gap-2">
                            <!-- 기본 타워 -->
                            <button data-tower-type="archer" class="tower-button flex flex-col items-center p-2 bg-slate-800 rounded-lg border border-slate-600 transition-all duration-200 relative">
                                <span class="text-3xl">🏹</span>
                                <span class="font-bold text-sm">궁수</span>
                                <span class="text-yellow-400 text-sm">20💰</span>
                                <div class="tooltip hidden absolute bottom-full mb-2 w-max px-2 py-1 bg-gray-800 text-white text-xs rounded z-10"></div>
                            </button>
                            <button data-tower-type="barracks" class="tower-button flex flex-col items-center p-2 bg-slate-800 rounded-lg border border-slate-600 transition-all duration-200 relative">
                                <span class="text-3xl">🛡️</span>
                                <span class="font-bold text-sm">병영</span>
                                <span class="text-yellow-400 text-sm">20💰</span>
                                <div class="tooltip hidden absolute bottom-full mb-2 w-max px-2 py-1 bg-gray-800 text-white text-xs rounded z-10"></div>
                            </button>
                            <button data-tower-type="mage" class="tower-button flex flex-col items-center p-2 bg-slate-800 rounded-lg border border-slate-600 transition-all duration-200 relative">
                                <span class="text-3xl">🧙</span>
                                <span class="font-bold text-sm">마법사</span>
                                <span class="text-yellow-400 text-sm">50💰</span>
                                <div class="tooltip hidden absolute bottom-full mb-2 w-max px-2 py-1 bg-gray-800 text-white text-xs rounded z-10"></div>
                            </button>
                             <button data-tower-type="cannon" class="tower-button flex flex-col items-center p-2 bg-slate-800 rounded-lg border border-slate-600 transition-all duration-200 relative">
                                <span class="text-3xl">💣</span>
                                <span class="font-bold text-sm">대포</span>
                                <span class="text-yellow-400 text-sm">70💰</span>
                                <div class="tooltip hidden absolute bottom-full mb-2 w-max px-2 py-1 bg-gray-800 text-white text-xs rounded z-10"></div>
                            </button>
                            <!-- 해금 타워 -->
                            <button data-tower-type="laboratory" class="tower-button locked flex flex-col items-center p-2 bg-slate-900 rounded-lg border border-slate-700 transition-all duration-200 relative">
                                <span class="text-3xl opacity-30">🔬</span>
                                <span class="font-bold text-sm text-slate-500">연구소</span>
                                <span class="text-yellow-400 text-sm">100💰</span>
                                <div class="lock-overlay absolute inset-0 flex items-center justify-center bg-black bg-opacity-60 rounded-lg"><span class="text-2xl">🔒</span></div>
                                <div class="tooltip hidden absolute bottom-full mb-2 w-max px-2 py-1 bg-gray-800 text-white text-xs rounded z-10"></div>
                            </button>
                            <button data-tower-type="trainingCamp" class="tower-button locked flex flex-col items-center p-2 bg-slate-900 rounded-lg border border-slate-700 transition-all duration-200 relative">
                                <span class="text-3xl opacity-30">💪</span>
                                <span class="font-bold text-sm text-slate-500">훈련소</span>
                                <span class="text-yellow-400 text-sm">120💰</span>
                                <div class="lock-overlay absolute inset-0 flex items-center justify-center bg-black bg-opacity-60 rounded-lg"><span class="text-2xl">🔒</span></div>
                                <div class="tooltip hidden absolute bottom-full mb-2 w-max px-2 py-1 bg-gray-800 text-white text-xs rounded z-10"></div>
                            </button>
                            <button data-tower-type="library" class="tower-button locked flex flex-col items-center p-2 bg-slate-900 rounded-lg border border-slate-700 transition-all duration-200 relative">
                                <span class="text-3xl opacity-30">🏛️</span>
                                <span class="font-bold text-sm text-slate-500">도서관</span>
                                <span class="text-yellow-400 text-sm">80💰</span>
                                <div class="lock-overlay absolute inset-0 flex items-center justify-center bg-black bg-opacity-60 rounded-lg"><span class="text-2xl">🔒</span></div>
                                <div class="tooltip hidden absolute bottom-full mb-2 w-max px-2 py-1 bg-gray-800 text-white text-xs rounded z-10"></div>
                            </button>
                        </div>
                    </div>

                    <!-- 타워 관리 UI (초기에는 숨김) -->
                    <div id="tower-management-ui" class="hidden">
                        <div class="flex items-center gap-2">
                            <div id="selected-tower-info" class="flex-1 text-center">
                                <p id="selected-tower-name" class="text-lg font-bold">타워 이름</p>
                                <p id="selected-tower-level" class="text-sm text-slate-400">레벨 1</p>
                                <p id="selected-tower-description" class="text-xs text-cyan-300 mt-1"></p>
                            </div>
                            <button id="move-button" class="bg-green-700 hover:bg-green-600 rounded-lg p-3 font-bold transition-colors">이동</button>
                            <button id="upgrade-button" class="flex-1 bg-blue-600 hover:bg-blue-500 rounded-lg p-3 text-lg font-bold transition-colors">업글</button>
                            <button id="sell-button" class="bg-red-700 hover:bg-red-600 rounded-lg p-3 font-bold transition-colors">판매</button>
                        </div>
                        <button id="close-management-ui" class="w-full mt-2 bg-slate-700 hover:bg-slate-600 rounded-lg p-2 text-sm">닫기</button>
                    </div>
                </div>
                
                <!-- 활동 패널 -->
                <div id="panel-activity" class="tab-panel absolute inset-0 hidden">
                    <p class="text-center text-sm text-slate-400 mb-2">활동을 시작하여 100💰을 즉시 얻으세요</p>
                    <div id="activity-buttons-container" class="grid grid-cols-3 gap-2">
                         <button data-activity="study" class="activity-button flex flex-col items-center p-2 bg-slate-800 rounded-lg border border-slate-600 disabled:bg-slate-700 disabled:cursor-not-allowed">
                            <span class="text-3xl">📚</span>
                            <span class="font-bold">공부 (<span id="study-count">0</span>)</span>
                            <span class="text-xs text-slate-400">25분</span>
                        </button>
                        <button data-activity="exercise" class="activity-button flex flex-col items-center p-2 bg-slate-800 rounded-lg border border-slate-600 disabled:bg-slate-700 disabled:cursor-not-allowed">
                            <span class="text-3xl">🏋️</span>
                            <span class="font-bold">운동 (<span id="exercise-count">0</span>)</span>
                            <span class="text-xs text-slate-400">25분</span>
                        </button>
                        <button data-activity="reading" class="activity-button flex flex-col items-center p-2 bg-slate-800 rounded-lg border border-slate-600 disabled:bg-slate-700 disabled:cursor-not-allowed">
                            <span class="text-3xl">📖</span>
                            <span class="font-bold">독서 (<span id="reading-count">0</span>)</span>
                            <span class="text-xs text-slate-400">25분</span>
                        </button>
                    </div>
                    <button id="give-up-activity-button" class="hidden w-full mt-2 bg-red-800 hover:bg-red-700 rounded-lg p-3 font-bold transition-colors">
                        활동 포기 (-100💰)
                    </button>
                </div>
            </div>
            
            <!-- 하단 고정 버튼 -->
            <div class="mt-2 grid grid-cols-1 gap-2">
                <button id="start-wave-button" class="w-full bg-green-600 hover:bg-green-500 rounded-lg p-4 text-xl font-bold transition-colors disabled:bg-slate-600 disabled:cursor-not-allowed">
                    웨이브 시작
                </button>
                <div class="grid grid-cols-2 gap-2">
                    <button id="pause-button" class="w-full p-3 bg-slate-700 hover:bg-slate-600 rounded-lg font-bold flex items-center justify-center">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>
                    </button>
                    <button id="give-up-button" class="w-full p-3 bg-red-800 hover:bg-red-700 rounded-lg font-bold disabled:bg-slate-600 disabled:cursor-not-allowed" disabled>웨이브 재시도</button>
                </div>
            </div>
        </div>
    </div>

    <!-- 모달 -->
    <div id="modal" class="absolute inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 z-50">
        <div id="modal-content" class="bg-[#16223b] p-8 rounded-2xl shadow-lg text-center border-2 border-slate-600 max-w-sm w-full fade-in">
            <h2 id="modal-title" class="text-4xl font-bold mb-4 text-cyan-400">제미나이 디펜스</h2>
            <p id="modal-text" class="text-slate-300 mb-6">다가오는 적들로부터 코어를 지켜내세요! 타워를 건설하고 업그레이드하여 승리하세요.</p>
            <button id="modal-button" class="w-full bg-cyan-600 hover:bg-cyan-500 rounded-lg p-4 text-xl font-bold transition-colors">게임 시작</button>
        </div>
    </div>
    
    <!-- 일시정지 모달 -->
    <div id="pause-modal" class="hidden absolute inset-0 bg-black bg-opacity-70 flex-col items-center justify-center p-4 z-40">
        <h2 class="text-6xl font-bold text-cyan-400 animate-pulse">일시정지</h2>
        <p class="mt-4 text-slate-300">화면을 터치하여 계속하기</p>
    </div>

    <!-- 확인 모달 -->
    <div id="confirm-modal" class="hidden absolute inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 z-50">
        <div class="bg-[#16223b] p-8 rounded-2xl shadow-lg text-center border-2 border-slate-600 max-w-sm w-full fade-in">
            <h2 id="confirm-title" class="text-2xl font-bold mb-4 text-yellow-400">확인</h2>
            <p id="confirm-text" class="text-slate-300 mb-6"></p>
            <div class="flex gap-4">
                <button id="confirm-yes-button" class="flex-1 bg-red-700 hover:bg-red-600 rounded-lg p-3 font-bold transition-colors">예</button>
                <button id="confirm-no-button" class="flex-1 bg-slate-600 hover:bg-slate-500 rounded-lg p-3 font-bold transition-colors">아니오</button>
            </div>
        </div>
    </div>

<script>
// ==================================
// 초기 설정 및 전역 변수
// ==================================
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// UI 요소
const ui = {
    health: document.getElementById('health'),
    resources: document.getElementById('resources'),
    wave: document.getElementById('wave'),
    towerButtons: document.querySelectorAll('.tower-button'),
    towerSelectionUI: document.getElementById('tower-selection-ui'),
    towerManagementUI: document.getElementById('tower-management-ui'),
    selectedTowerName: document.getElementById('selected-tower-name'),
    selectedTowerLevel: document.getElementById('selected-tower-level'),
    selectedTowerDescription: document.getElementById('selected-tower-description'),
    upgradeButton: document.getElementById('upgrade-button'),
    sellButton: document.getElementById('sell-button'),
    moveButton: document.getElementById('move-button'),
    closeManagementUI: document.getElementById('close-management-ui'),
    startWaveButton: document.getElementById('start-wave-button'),
    tabButtons: document.querySelectorAll('.tab-button'),
    tabPanels: document.querySelectorAll('.tab-panel'),
    activityButtons: document.querySelectorAll('.activity-button'),
    activityButtonsContainer: document.getElementById('activity-buttons-container'),
    giveUpActivityButton: document.getElementById('give-up-activity-button'),
    giveUpButton: document.getElementById('give-up-button'),
    activityCounts: {
        study: document.getElementById('study-count'),
        exercise: document.getElementById('exercise-count'),
        reading: document.getElementById('reading-count'),
    },
    modal: document.getElementById('modal'),
    modalTitle: document.getElementById('modal-title'),
    modalText: document.getElementById('modal-text'),
    modalButton: document.getElementById('modal-button'),
    pauseButton: document.getElementById('pause-button'),
    pauseModal: document.getElementById('pause-modal'),
    confirmModal: document.getElementById('confirm-modal'),
    confirmTitle: document.getElementById('confirm-title'),
    confirmText: document.getElementById('confirm-text'),
    confirmYesButton: document.getElementById('confirm-yes-button'),
    confirmNoButton: document.getElementById('confirm-no-button'),
};

// 게임 상태 객체
let gameState = {};
let confirmAction = null;

// 사운드 신스
let synth, hitSynth;
let lastSoundTime = 0;
const soundOffset = 0.001;

// 게임 데이터
const TOWER_DATA = {
    archer: { name: '궁수 타워', icon: '🏹', costs: [20, 40, 70], damages: [8, 12, 18], ranges: [120, 130, 140], fireRates: [30, 27, 24], projectileType: 'arrow', description: '단일 적에게 빠른 화살을 발사합니다.' },
    barracks: { name: '병영', icon: '🛡️', costs: [20, 40, 70], spawnRates: [400, 350, 300], maxSoldiers: [1, 2, 3], soldierHealth: [60, 80, 110], soldierDamage: [5, 8, 12], description: '경로를 막는 병사를 생성합니다.' },
    mage: { name: '마법사 길드', icon: '🧙', costs: [50, 80, 120], damages: [25, 40, 60], ranges: [100, 105, 110], fireRates: [90, 85, 80], projectileType: 'magic', description: '강력한 마법 구체를 발사합니다.' },
    cannon: { name: '대포', icon: '💣', costs: [70, 110, 160], damages: [20, 30, 45], ranges: [90, 95, 100], fireRates: [120, 110, 100], splashRadius: [30, 35, 40], projectileType: 'cannonball', description: '범위 피해를 주는 포탄을 발사합니다.' },
    laboratory: { name: '연구소', icon: '🔬', costs: [100], damages: [0], ranges: [80], fireRates: [0], unlockActivity: 'study', unlocked: false, buff: { type: 'damage', value: 1.10 }, description: '주변 타워 공격력 +10%' },
    trainingCamp: { name: '훈련소', icon: '💪', costs: [120], damages: [0], ranges: [80], fireRates: [0], unlockActivity: 'exercise', unlocked: false, buff: { type: 'health', value: 1.20 }, description: '주변 병영 병사 체력 +20%' },
    library: { name: '도서관', icon: '🏛️', costs: [80], damages: [0], ranges: [0], fireRates: [0], income: 5, incomeRate: 120, unlockActivity: 'reading', unlocked: false, description: '2초마다 5💰를 생성합니다.' }
};
const ACTIVITY_DATA = {
    duration: 25 * 60 * 60, // 10초 (600 프레임)
    preCountdownDuration: 5 * 60, // 5초
};

// ==================================
// 게임 초기화 함수
// ==================================
function init() {
    // 기존 게임 루프 및 타임아웃 정리
    if (gameState.timeoutIds) {
        gameState.timeoutIds.forEach(id => clearTimeout(id));
    }
    if (gameState.animationFrameId) {
        cancelAnimationFrame(gameState.animationFrameId);
    }

    // 해금 타워 리셋
    for (const type in TOWER_DATA) {
        if (TOWER_DATA[type].unlockActivity) {
            TOWER_DATA[type].unlocked = false;
        }
    }

    // 게임 상태 리셋
    gameState = {
        health: 20,
        resources: 130,
        wave: 0,
        totalWaves: 10,
        towers: [],
        enemies: [],
        projectiles: [],
        particles: [],
        soldiers: [],
        towerSlots: [],
        enemyPath: [],
        selectedTowerType: 'archer',
        selectedTower: null,
        waveInProgress: false,
        spawningComplete: false,
        gameOver: false,
        gameWon: false,
        isPaused: false,
        animationFrameId: null,
        isMovingTower: false,
        towerToMove: null,
        activityInProgress: null,
        activityTimer: 0,
        activityPending: null,
        activityPreCountdown: 0,
        completedActivities: { study: 0, exercise: 0, reading: 0 },
        mousePos: { x: 0, y: 0 },
        preWaveState: null,
        timeoutIds: [],
        notification: null,
    };

    // 컨테이너 기반 캔버스 크기 설정
    const container = document.getElementById('canvas-container');
    canvas.width = container.offsetWidth;
    canvas.height = container.offsetHeight;

    // 캔버스 크기에 따른 적 경로 정의
    const pathPoints = [
        { x: 0.5, y: 0 }, { x: 0.5, y: 0.2 }, { x: 0.8, y: 0.2 }, { x: 0.8, y: 0.4 },
        { x: 0.2, y: 0.4 }, { x: 0.2, y: 0.6 }, { x: 0.8, y: 0.6 }, { x: 0.8, y: 0.8 },
        { x: 0.5, y: 0.8 }, { x: 0.5, y: 1.0 }
    ];
    gameState.enemyPath = pathPoints.map(p => ({ x: p.x * canvas.width, y: p.y * canvas.height }));

    // 캔버스 크기에 따른 타워 슬롯 위치 정의
    const slotPoints = [
        { x: 0.25, y: 0.1 }, { x: 0.75, y: 0.1 }, 
        { x: 0.65, y: 0.3 }, { x: 0.95, y: 0.3 },
        { x: 0.5, y: 0.5 },
        { x: 0.05, y: 0.5 }, { x: 0.35, y: 0.5 },
        { x: 0.5, y: 0.7 },
        { x: 0.95, y: 0.7 },
        { x: 0.65, y: 0.9 }
    ];
    gameState.towerSlots = slotPoints.map(p => ({ x: p.x * canvas.width, y: p.y * canvas.height, tower: null }));
    
    // UI 업데이트 및 게임 루프 시작
    updateUI();
    updateTowerButtonsUI();
    selectTowerType('archer');
    showTowerSelectionUI();
    updateDynamicButtons();
    updateActivityCountUI();
    
    gameLoop();
}

// ==================================
// 게임 루프 및 렌더링
// ==================================
function gameLoop() {
    if (gameState.gameOver) return;
    
    gameState.animationFrameId = requestAnimationFrame(gameLoop);
    
    if (gameState.isPaused) return;

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    drawPath();
    drawTowerSlots();
    
    if (gameState.activityPreCountdown > 0) {
        gameState.activityPreCountdown--;
        drawPreActivityCountdown();
        if (gameState.activityPreCountdown <= 0) {
            gameState.resources += 100;
            updateUI();
            gameState.activityInProgress = gameState.activityPending;
            gameState.activityPending = null;
            gameState.activityTimer = ACTIVITY_DATA.duration;
        }
    } else if (gameState.activityInProgress) {
        gameState.activityTimer--;
        if (gameState.activityTimer <= 0) {
            completeActivity();
        }
    }

    // 객체 업데이트
    gameState.towers.forEach(t => t.update());
    gameState.soldiers.forEach(s => s.update());
    gameState.enemies.forEach(e => e.update());
    gameState.projectiles.forEach(p => p.update());
    gameState.particles.forEach(p => p.update());

    // 객체 그리기
    gameState.towers.forEach(t => t.draw());
    gameState.soldiers.forEach(s => s.draw());
    gameState.enemies.forEach(e => e.draw());
    gameState.projectiles.forEach(p => p.draw());
    gameState.particles.forEach(p => p.draw());

    // UI 그리기
    if (gameState.isMovingTower && gameState.towerToMove) drawMovingTower();
    if (gameState.activityInProgress) drawActivityTimer();
    if (gameState.notification && gameState.notification.timer > 0) {
        gameState.notification.timer--;
        drawNotification();
    } else {
        gameState.notification = null;
    }

    // 비활성 객체 필터링
    gameState.enemies = gameState.enemies.filter(e => e.active);
    gameState.projectiles = gameState.projectiles.filter(p => p.active);
    gameState.particles = gameState.particles.filter(p => p.active);
    gameState.soldiers = gameState.soldiers.filter(s => s.active);

    // 웨이브 종료 조건 확인
    if (gameState.waveInProgress && gameState.spawningComplete && gameState.enemies.length === 0) {
        endWave();
    }
}

function drawPath() {
    ctx.strokeStyle = 'rgba(100, 116, 139, 0.4)';
    ctx.lineWidth = 30; // 길목 너비 증가
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(gameState.enemyPath[0].x, gameState.enemyPath[0].y);
    for (let i = 1; i < gameState.enemyPath.length; i++) {
        ctx.lineTo(gameState.enemyPath[i].x, gameState.enemyPath[i].y);
    }
    ctx.stroke();
}

function drawTowerSlots() {
    gameState.towerSlots.forEach((slot) => {
        const isHighlighted = gameState.isMovingTower && !slot.tower;
        ctx.fillStyle = slot.tower ? 'rgba(56, 189, 248, 0.1)' : 'rgba(255, 255, 255, 0.05)';
        ctx.strokeStyle = isHighlighted ? '#facc15' : 'rgba(100, 116, 139, 0.7)';
        ctx.lineWidth = isHighlighted ? 3 : 2;
        ctx.beginPath();
        ctx.arc(slot.x, slot.y, 20, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
    });
}

function drawMovingTower() {
    const tower = gameState.towerToMove;
    const data = TOWER_DATA[tower.type];
    ctx.globalAlpha = 0.7;
    ctx.font = '24px Jua';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(data.icon, gameState.mousePos.x, gameState.mousePos.y);
    ctx.globalAlpha = 1;
}

function drawActivityTimer() {
    const progress = 1 - (gameState.activityTimer / ACTIVITY_DATA.duration);
    const barWidth = canvas.width * 0.8;
    const barX = (canvas.width - barWidth) / 2;
    
    ctx.fillStyle = "rgba(0,0,0,0.5)";
    ctx.fillRect(barX, 20, barWidth, 30);
    
    ctx.fillStyle = "#22c55e";
    ctx.fillRect(barX, 20, barWidth * progress, 30);
    
    const totalSeconds = Math.ceil(gameState.activityTimer / 60);
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    const timeString = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;

    ctx.fillStyle = "white";
    ctx.font = "16px Jua";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(`${gameState.activityInProgress.toUpperCase()} 중... ${timeString}`, canvas.width / 2, 35);
}

function drawPreActivityCountdown() {
    const seconds = Math.ceil(gameState.activityPreCountdown / 60);
    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    ctx.fillStyle = 'white';
    ctx.textAlign = 'center';
    
    ctx.font = '80px Jua';
    ctx.fillText(seconds, canvas.width / 2, canvas.height / 2 - 40);
    
    ctx.font = '20px Jua';
    ctx.fillText("5초간 숨을 고르고, 바로 시작하세요!", canvas.width / 2, canvas.height / 2 + 40);
}

function drawNotification() {
    if (!gameState.notification) return;
    const alpha = Math.min(1, gameState.notification.timer / 60); // 마지막 1초 동안 사라짐
    ctx.save();
    ctx.textAlign = 'center';
    ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
    ctx.font = '18px Jua';
    ctx.shadowColor = 'black';
    ctx.shadowBlur = 5;
    ctx.fillText(gameState.notification.message, canvas.width / 2, 30);
    ctx.restore();
}


// ==================================
// 클래스 정의
// ==================================
class Soldier {
    constructor(tower, rallyPoint, initialHealth) {
        this.tower = tower;
        this.x = rallyPoint.x;
        this.y = rallyPoint.y;
        this.health = initialHealth;
        this.maxHealth = initialHealth;
        this.damage = TOWER_DATA.barracks.soldierDamage[tower.level];
        this.attackRange = 40;
        this.attackCooldown = 0;
        this.attackRate = 60; // 1초에 한 번 공격
        this.target = null;
        this.active = true;
    }

    update() {
        if (!this.active || gameState.isPaused) return;

        this.attackCooldown--;
        if (!this.target || !this.target.active || getDistance(this, this.target) > this.attackRange) {
            this.findTarget();
        }

        if (this.target && this.attackCooldown <= 0) {
            this.target.takeDamage(this.damage);
            gameState.particles.push(new Particle(this.target.x, this.target.y, '#ffffff', 1));
            this.attackCooldown = this.attackRate;
        }
    }

    findTarget() {
        this.target = null;
        let closestDist = this.attackRange;
        for (const enemy of gameState.enemies) {
            const dist = getDistance(this, enemy);
            if (dist < closestDist) {
                closestDist = dist;
                this.target = enemy;
            }
        }
    }

    draw() {
        ctx.fillStyle = '#a1a1aa';
        ctx.beginPath();
        ctx.arc(this.x, this.y, 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#e4e4e7';
        ctx.lineWidth = 2;
        ctx.stroke();

        const healthBarWidth = 20;
        ctx.fillStyle = '#3f3f46';
        ctx.fillRect(this.x - healthBarWidth / 2, this.y - 15, healthBarWidth, 4);
        ctx.fillStyle = '#10b981';
        ctx.fillRect(this.x - healthBarWidth / 2, this.y - 15, healthBarWidth * (this.health / this.maxHealth), 4);
    }

    takeDamage(amount) {
        this.health -= amount;
        if (this.health <= 0) {
            this.active = false;
            const index = this.tower.soldiers.indexOf(this);
            if (index > -1) {
                this.tower.soldiers.splice(index, 1);
            }
        }
    }
}

class Enemy {
    constructor(wave, isUnique = false) {
        this.path = gameState.enemyPath;
        this.pathIndex = 0;
        this.x = this.path[0].x;
        this.y = this.path[0].y;
        this.isUnique = isUnique;

        if (this.isUnique) {
            this.radius = 10;
            this.speed = 0.7 + wave * 0.1;
            this.health = 100 + wave * 30;
            this.resourceValue = 2; // 유니크 유닛 처치 시 자원 2 획득
            this.damage = 10 + wave * 2;
        } else {
            this.radius = 7 + Math.random() * 3;
            this.speed = 0.5 + wave * 0.1 + Math.random() * 0.2;
            this.health = 20 + wave * 12;
            this.resourceValue = 1; // 일반 유닛 처치 시 자원 1 획득
            this.damage = 5 + wave;
        }
        
        this.maxHealth = this.health;
        this.active = true;
        this.slowed = false;
        this.slowTimer = 0;
        this.blockingSoldier = null;
        this.attackCooldown = 0;
        this.attackRate = 60;
    }

    update() {
        if (!this.active || gameState.isPaused) return;
        if (gameState.activityInProgress || gameState.activityPreCountdown > 0) return;

        this.attackCooldown--;

        if (this.blockingSoldier && !this.blockingSoldier.active) {
            this.blockingSoldier = null;
        }
        if (!this.blockingSoldier) {
            this.findBlockingSoldier();
        }

        if (this.blockingSoldier) {
            if (this.attackCooldown <= 0) {
                this.blockingSoldier.takeDamage(this.damage);
                this.attackCooldown = this.attackRate;
            }
            return; 
        }

        const currentSpeed = this.slowed ? this.speed * 0.5 : this.speed;
        if (this.slowed) { this.slowTimer--; if (this.slowTimer <= 0) this.slowed = false; }

        if (this.pathIndex < this.path.length - 1) {
            const target = this.path[this.pathIndex + 1];
            const dx = target.x - this.x;
            const dy = target.y - this.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < currentSpeed) { this.pathIndex++; } 
            else { this.x += (dx / dist) * currentSpeed; this.y += (dy / dist) * currentSpeed; }
        } else {
            this.active = false;
            if (this.isUnique) {
                gameState.health -= 2; // 유니크 유닛은 체력 2 감소
            } else {
                gameState.health--;
            }
            updateUI();
            if (gameState.health <= 0) {
                gameOver(false);
            }
        }
    }
    
    findBlockingSoldier() {
        let closestDist = 25; 
        for (const soldier of gameState.soldiers) {
            const dist = getDistance(this, soldier);
            if (dist < closestDist) {
                this.blockingSoldier = soldier;
                break;
            }
        }
    }

    draw() {
        if (this.isUnique) {
            ctx.fillStyle = '#a855f7';
            ctx.strokeStyle = '#f0abfc';
            ctx.lineWidth = 3;
        } else {
            ctx.fillStyle = this.slowed ? '#60a5fa' : '#f87171';
            ctx.strokeStyle = '#fca5a5';
            ctx.lineWidth = 1;
        }

        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
        if (this.isUnique) ctx.stroke();
        
        const healthBarWidth = 25;
        ctx.fillStyle = '#3f3f46';
        ctx.fillRect(this.x - healthBarWidth / 2, this.y - this.radius - 8, healthBarWidth, 4);
        ctx.fillStyle = '#10b981';
        ctx.fillRect(this.x - healthBarWidth / 2, this.y - this.radius - 8, healthBarWidth * (this.health / this.maxHealth), 4);
    }

    takeDamage(amount) {
        this.health -= amount;
        if (this.health <= 0) {
            this.active = false;
            gameState.resources += this.resourceValue;
            updateUI();
        }
    }

    applySlow(duration) {
        this.slowed = true;
        this.slowTimer = duration;
    }
}

class Tower {
    constructor(slot, type) {
        this.slot = slot;
        this.x = slot.x;
        this.y = slot.y;
        this.type = type;
        this.level = 0;
        this.target = null;
        this.fireCooldown = 0;
        this.setStats();

        if (this.type === 'barracks') {
            this.soldiers = [];
            this.spawnCooldown = 0;
            this.rallyPoint = findClosestPathPoint(this.x, this.y, 0);
        } else if (this.type === 'library') {
            this.incomeCooldown = this.incomeRate;
        }
    }

    setStats() {
        const data = TOWER_DATA[this.type];
        this.cost = data.costs[this.level];
        this.damage = data.damages ? data.damages[this.level] : 0;
        this.range = data.ranges ? data.ranges[this.level] : 0;
        this.fireRate = data.fireRates ? data.fireRates[this.level] : 0;
        if (data.splashRadius) this.splashRadius = data.splashRadius[this.level];
        if (data.spawnRates) {
            this.spawnRate = data.spawnRates[this.level];
            this.maxSoldiers = data.maxSoldiers[this.level];
        }
        if (data.incomeRate) this.incomeRate = data.incomeRate;
        if (data.income) this.income = data.income;
    }

    update() {
        if (gameState.isMovingTower && gameState.towerToMove === this) return;
        if (gameState.activityInProgress || gameState.activityPreCountdown > 0 || gameState.isPaused) return;

        if (this.type === 'barracks') {
            this.spawnCooldown--;
            if (this.spawnCooldown <= 0 && this.soldiers.length < this.maxSoldiers) {
                let finalHealth = TOWER_DATA.barracks.soldierHealth[this.level];
                gameState.towers.forEach(t => {
                    if (t.type === 'trainingCamp' && getDistance(this, t) <= t.range) {
                        finalHealth *= t.buff.value;
                    }
                });
                const rallyX = this.rallyPoint.x + (Math.random() - 0.5) * 15;
                const rallyY = this.rallyPoint.y + (Math.random() - 0.5) * 15;
                const newSoldier = new Soldier(this, { x: rallyX, y: rallyY }, finalHealth);
                this.soldiers.push(newSoldier);
                gameState.soldiers.push(newSoldier);
                this.spawnCooldown = this.spawnRate;
            }
        } else if (this.type === 'library') {
            this.incomeCooldown--;
            if (this.incomeCooldown <= 0) {
                gameState.resources += this.income;
                updateUI();
                gameState.particles.push(new Particle(this.x, this.y, '#facc15', 2));
                this.incomeCooldown = this.incomeRate;
            }
        } else if (this.type === 'laboratory' || this.type === 'trainingCamp') {
            // Aura towers are passive, no update needed here
        } else {
            this.fireCooldown--;
            if (this.fireCooldown <= 0) {
                this.findTarget();
                if (this.target) {
                    this.fire();
                    this.fireCooldown = this.fireRate;
                }
            }
        }
    }

    findTarget() {
        this.target = null;
        let closestDist = this.range;
        for (const enemy of gameState.enemies) {
            const dist = getDistance(this, enemy);
            if (dist < closestDist) {
                closestDist = dist;
                this.target = enemy;
            }
        }
    }

    fire() {
        if (!this.target) return;
        let finalDamage = this.damage;
        gameState.towers.forEach(t => {
            if (t.type === 'laboratory' && getDistance(this, t) <= t.range) {
                finalDamage *= t.buff.value;
            }
        });

        const data = TOWER_DATA[this.type];
        gameState.projectiles.push(new Projectile(this, this.target, finalDamage, data.projectileType, this.splashRadius));
        playSound('shoot');
    }
    
    draw() {
        if (gameState.isMovingTower && gameState.towerToMove === this) return;
        const data = TOWER_DATA[this.type];
        ctx.font = '24px Jua';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(data.icon, this.x, this.y);
        ctx.fillStyle = 'white';
        ctx.font = '10px Jua';
        ctx.fillText(`Lv.${this.level + 1}`, this.x, this.y + 15);
        if (gameState.selectedTower === this && this.range > 0) {
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.range, 0, Math.PI * 2);
            ctx.stroke();
        }
        if (this.type === 'barracks' && this.rallyPoint) {
            ctx.strokeStyle = '#a1a1aa';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(this.x, this.y);
            ctx.lineTo(this.rallyPoint.x, this.rallyPoint.y);
            ctx.stroke();
            ctx.strokeRect(this.rallyPoint.x - 5, this.rallyPoint.y - 5, 10, 10);
        }
    }

    upgrade() {
        const data = TOWER_DATA[this.type];
        if (this.level < data.costs.length - 1) {
            const upgradeCost = data.costs[this.level + 1];
            if (gameState.resources >= upgradeCost) {
                gameState.resources -= upgradeCost;
                this.level++;
                this.setStats();
                playSound('upgrade');
                return true;
            }
        }
        return false;
    }

    sell() {
        let totalCost = 0;
        for (let i = 0; i <= this.level; i++) { totalCost += TOWER_DATA[this.type].costs[i]; }
        gameState.resources += totalCost;
        this.slot.tower = null;
        if (this.type === 'barracks') {
            this.soldiers.forEach(s => s.active = false);
        }
        gameState.towers = gameState.towers.filter(t => t !== this);
        playSound('sell');
    }
}

class Projectile {
    constructor(source, target, damage, type = 'normal', splashRadius = 0) {
        this.x = source.x; this.y = source.y; this.target = target;
        this.damage = damage; this.speed = 5; this.radius = 3;
        this.active = true; this.type = type; this.splashRadius = splashRadius;
    }
    
    update() {
        if (!this.active || !this.target.active || gameState.activityInProgress || gameState.activityPreCountdown > 0 || gameState.isPaused) {
            if (!this.target.active) this.active = false;
            return;
        }
        const dx = this.target.x - this.x; const dy = this.target.y - this.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < this.target.radius) {
            this.active = false;
            playSound('hit');
            if (this.type === 'cannonball') {
                dealSplashDamage(this.target.x, this.target.y, this.damage, this.splashRadius);
                for (let i = 0; i < 20; i++) gameState.particles.push(new Particle(this.target.x, this.target.y, '#f97316', 3));
            } else {
                this.target.takeDamage(this.damage);
                for (let i = 0; i < 5; i++) gameState.particles.push(new Particle(this.x, this.y, this.getColor()));
            }
        } else {
            this.x += (dx / dist) * this.speed; this.y += (dy / dist) * this.speed;
        }
    }

    draw() {
        ctx.fillStyle = this.getColor();
        ctx.beginPath();
        if (this.type === 'cannonball') {
            ctx.arc(this.x, this.y, 5, 0, Math.PI * 2);
        } else {
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        }
        ctx.fill();
    }
    
    getColor() {
        switch(this.type) {
            case 'arrow': return '#f59e0b';
            case 'magic': return '#8b5cf6';
            case 'cannonball': return '#44403c';
            default: return '#67e8f9';
        }
    }
}

class Particle {
    constructor(x, y, color, size = 1) {
        this.x = x; this.y = y; this.color = color;
        this.size = (Math.random() * 2 + 1) * size; this.life = 30;
        this.active = true; this.vx = (Math.random() - 0.5) * 3;
        this.vy = (Math.random() - 0.5) * 3;
    }
    update() {
        if (gameState.isPaused) return;
        this.life--;
        if (this.life <= 0) this.active = false;
        this.x += this.vx; this.y += this.vy;
    }
    draw() {
        ctx.globalAlpha = this.life / 30;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
    }
}

// ==================================
// 게임 로직 및 유틸리티 함수
// ==================================
function getDistance(obj1, obj2) {
    const dx = obj1.x - obj2.x;
    const dy = obj1.y - obj2.y;
    return Math.sqrt(dx * dx + dy * dy);
}

function findClosestPathPoint(x, y, offset = 0) {
    let closestPoint = null;
    let minDistance = Infinity;

    for (let i = 0; i < gameState.enemyPath.length - 1; i++) {
        const p1 = gameState.enemyPath[i];
        const p2 = gameState.enemyPath[i + 1];
        
        const lenSq = (p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2;
        if (lenSq === 0) continue;

        let t = ((x - p1.x) * (p2.x - p1.x) + (y - p1.y) * (p2.y - p1.y)) / lenSq;
        t = Math.max(0, Math.min(1, t));

        const closest = { x: p1.x + t * (p2.x - p1.x), y: p1.y + t * (p2.y - p1.y) };
        const distSq = (x - closest.x) ** 2 + (y - closest.y) ** 2;

        if (distSq < minDistance) {
            minDistance = distSq;
            closestPoint = closest;
        }
    }
    if (closestPoint && offset !== 0) {
        const dx = x - closestPoint.x;
        const dy = y - closestPoint.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (dist > 0) {
            closestPoint.x += (dx / dist) * offset;
            closestPoint.y += (dy / dist) * offset;
        }
    }
    return closestPoint;
}

function dealSplashDamage(x, y, damage, radius) {
    gameState.enemies.forEach(enemy => {
        if (getDistance({x, y}, enemy) <= radius) {
            enemy.takeDamage(damage);
        }
    });
}

function startWave() {
    if (gameState.waveInProgress || gameState.activityInProgress || gameState.activityPreCountdown > 0) return;
    
    gameState.preWaveState = {
        health: gameState.health,
        resources: gameState.resources,
        towers: gameState.towers.map(t => ({
            type: t.type,
            level: t.level,
            slotIndex: gameState.towerSlots.indexOf(t.slot)
        })),
        completedActivities: JSON.parse(JSON.stringify(gameState.completedActivities))
    };

    gameState.waveInProgress = true;
    gameState.spawningComplete = false;
    gameState.wave++;
    
    updateDynamicButtons();
    
    const normalEnemyCount = 8 + gameState.wave * 4;
    const spawnInterval = 300;
    let totalSpawns = normalEnemyCount;

    for (let i = 0; i < normalEnemyCount; i++) {
        const timeoutId = setTimeout(() => {
            if (!gameState.gameOver) gameState.enemies.push(new Enemy(gameState.wave, false));
        }, i * spawnInterval);
        gameState.timeoutIds.push(timeoutId);
    }

    if (gameState.wave >= 3) {
        const uniqueEnemyCount = gameState.wave - 2; // 웨이브가 진행될수록 유니크 유닛 수가 1씩 증가 (3웨이브: 1, 4웨이브: 2, ...)
        totalSpawns += uniqueEnemyCount;
        for (let j = 0; j < uniqueEnemyCount; j++) {
            const spawnDelay = (normalEnemyCount + j) * spawnInterval;
            const timeoutId = setTimeout(() => {
                if (!gameState.gameOver) gameState.enemies.push(new Enemy(gameState.wave, true));
            }, spawnDelay);
            gameState.timeoutIds.push(timeoutId);
        }
    }

    const totalSpawnTime = (totalSpawns - 1) * spawnInterval;
    const completionTimeoutId = setTimeout(() => {
        if (!gameState.gameOver) gameState.spawningComplete = true;
    }, totalSpawnTime + 1);
    gameState.timeoutIds.push(completionTimeoutId);

    updateUI();
}

function endWave() {
    gameState.waveInProgress = false;
    gameState.spawningComplete = false;
    updateDynamicButtons();
    if (gameState.wave >= gameState.totalWaves) {
        gameOver(true);
    }
    updateUI();
}

function gameOver(isVictory) {
    if (gameState.gameOver) return;
    gameState.gameOver = true;
    gameState.gameWon = isVictory;
    cancelAnimationFrame(gameState.animationFrameId);
    gameState.timeoutIds.forEach(id => clearTimeout(id));
    ui.modalTitle.textContent = isVictory ? "승리!" : "게임 오버";
    ui.modalText.textContent = isVictory ? `축하합니다! 최종 점수: ${gameState.resources}` : `코어가 파괴되었습니다. 최종 웨이브: ${gameState.wave}`;
    ui.modalButton.textContent = "다시 시작";
    ui.modal.style.display = 'flex';
}

function retryWave() {
    if (!gameState.preWaveState) return;

    gameState.timeoutIds.forEach(id => clearTimeout(id));
    gameState.timeoutIds = [];
    gameState.enemies = [];
    gameState.projectiles = [];
    gameState.particles = [];
    gameState.soldiers.forEach(s => s.active = false);
    gameState.soldiers = [];
    gameState.waveInProgress = false;
    gameState.spawningComplete = false;

    const snapshot = gameState.preWaveState;
    gameState.health = snapshot.health;
    gameState.resources = snapshot.resources;
    gameState.wave--; 
    gameState.completedActivities = snapshot.completedActivities;

    gameState.towerSlots.forEach(slot => slot.tower = null);
    gameState.towers = [];
    snapshot.towers.forEach(towerData => {
        const slot = gameState.towerSlots[towerData.slotIndex];
        if (slot) {
            const newTower = new Tower(slot, towerData.type);
            newTower.level = towerData.level;
            newTower.setStats();
            slot.tower = newTower;
            gameState.towers.push(newTower);
        }
    });

    gameState.preWaveState = null;

    updateUI();
    updateDynamicButtons();
    updateActivityCountUI();
    showTowerSelectionUI();
    
    playSound('sell');
}


function startActivity(type) {
    if (gameState.waveInProgress || gameState.activityInProgress || gameState.activityPreCountdown > 0) return;
    gameState.activityPending = type;
    gameState.activityPreCountdown = ACTIVITY_DATA.preCountdownDuration;
    updateDynamicButtons();
    playSound('upgrade');
}

function completeActivity() {
    playSound('upgrade');
    const activityType = gameState.activityInProgress;
    if(activityType) {
        gameState.completedActivities[activityType]++;
        checkUnlocks(activityType);
    }
    gameState.activityInProgress = null;
    gameState.activityTimer = 0;
    updateUI();
    updateDynamicButtons();
    updateActivityCountUI();
}

function checkUnlocks(activityType) {
    for (const type in TOWER_DATA) {
        const data = TOWER_DATA[type];
        if (data.unlockActivity === activityType && !data.unlocked) {
            if (gameState.completedActivities[activityType] >= 1) {
                data.unlocked = true;
                updateTowerButtonsUI();
                showNotification(`${data.name} 타워 해금!`, 300);
                playSound('upgrade');
            }
        }
    }
}

function giveUpActivity() {
    if (!gameState.activityInProgress && gameState.activityPreCountdown <= 0) return;

    gameState.resources -= 100;
    if (gameState.resources < 0) gameState.resources = 0;

    gameState.activityInProgress = null;
    gameState.activityTimer = 0;
    gameState.activityPending = null;
    gameState.activityPreCountdown = 0;

    playSound('sell');
    updateUI();
    updateDynamicButtons();
}

function initiateMoveTower() {
    if (gameState.waveInProgress || gameState.activityInProgress || gameState.activityPreCountdown > 0 || !gameState.selectedTower) return;
    gameState.isMovingTower = true;
    gameState.towerToMove = gameState.selectedTower;
    showTowerSelectionUI();
}

function finalizeMoveTower(newSlot) {
    const tower = gameState.towerToMove;
    if (!tower || newSlot.tower) {
        gameState.isMovingTower = false;
        gameState.towerToMove = null;
        return;
    }
    tower.slot.tower = null;
    tower.slot = newSlot;
    tower.x = newSlot.x;
    tower.y = newSlot.y;
    newSlot.tower = tower;

    if (tower.type === 'barracks') {
        tower.rallyPoint = findClosestPathPoint(tower.x, tower.y, 0);
        tower.soldiers.forEach(s => s.active = false);
        tower.soldiers = [];
    }

    gameState.isMovingTower = false;
    gameState.towerToMove = null;
    playSound('build');
}

function togglePause() {
    if (gameState.gameOver) return;
    gameState.isPaused = !gameState.isPaused;
    if (gameState.isPaused) {
        ui.pauseModal.style.display = 'flex';
        ui.pauseButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>`;
    } else {
        ui.pauseModal.style.display = 'none';
        ui.pauseButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>`;
    }
}

// ==================================
// UI 및 이벤트 처리
// ==================================
function updateUI() {
    ui.health.textContent = gameState.health;
    ui.resources.textContent = gameState.resources;
    ui.wave.textContent = `${gameState.wave} / ${gameState.totalWaves}`;
    ui.startWaveButton.textContent = gameState.waveInProgress ? `웨이브 ${gameState.wave} 진행 중` : `웨이브 ${gameState.wave + 1} 시작`;
}

function updateTowerButtonsUI() {
    document.querySelectorAll('.tower-button').forEach(btn => {
        const type = btn.dataset.towerType;
        const data = TOWER_DATA[type];
        if (!data) return;

        const tooltip = btn.querySelector('.tooltip');

        if (data.unlockActivity && !data.unlocked) { // 잠긴 해금 타워
            btn.classList.add('locked', 'bg-slate-900', 'border-slate-700');
            btn.classList.remove('bg-slate-800', 'border-slate-600');
            btn.disabled = true;
            if (tooltip) {
                const activityName = data.unlockActivity === 'study' ? '공부' : data.unlockActivity === 'exercise' ? '운동' : '독서';
                tooltip.textContent = `${data.description} (해금: ${activityName} 1회)`;
            }
        } else { // 기본 타워 또는 해금된 타워
            btn.classList.remove('locked', 'bg-slate-900', 'border-slate-700');
            btn.classList.add('bg-slate-800', 'border-slate-600');
            btn.disabled = false;
            const icon = btn.querySelector('.text-3xl');
            if (icon) icon.classList.remove('opacity-30');
            const name = btn.querySelector('.font-bold');
            if(name) name.classList.remove('text-slate-500');
            if (tooltip) {
                tooltip.textContent = data.description;
            }
        }
    });
}


function updateDynamicButtons() {
    const isBuildPhase = !gameState.waveInProgress && !gameState.activityInProgress && !gameState.activityPreCountdown > 0;
    const isActivityPhase = gameState.activityInProgress || gameState.activityPreCountdown > 0;

    ui.startWaveButton.disabled = !isBuildPhase;
    ui.giveUpButton.disabled = !gameState.waveInProgress;
    
    if (isActivityPhase) {
        ui.activityButtonsContainer.classList.add('hidden');
        ui.giveUpActivityButton.classList.remove('hidden');
    } else {
        ui.activityButtonsContainer.classList.remove('hidden');
        ui.giveUpActivityButton.classList.add('hidden');
        ui.activityButtons.forEach(btn => btn.disabled = !isBuildPhase);
    }
    
    if (gameState.selectedTower) {
        showTowerManagementUI(gameState.selectedTower);
    }
}

function updateActivityCountUI() {
    ui.activityCounts.study.textContent = gameState.completedActivities.study;
    ui.activityCounts.exercise.textContent = gameState.completedActivities.exercise;
    ui.activityCounts.reading.textContent = gameState.completedActivities.reading;
}

function selectTowerType(type) {
    gameState.selectedTowerType = type;
    ui.towerButtons.forEach(btn => {
        btn.classList.toggle('selected', btn.dataset.towerType === type);
    });
}

function showTowerSelectionUI() {
    gameState.selectedTower = null;
    ui.towerManagementUI.classList.add('hidden');
    ui.towerSelectionUI.classList.remove('hidden');
}

function showTowerManagementUI(tower) {
    gameState.selectedTower = tower;
    const data = TOWER_DATA[tower.type];
    ui.selectedTowerName.textContent = data.name;
    ui.selectedTowerLevel.textContent = `레벨 ${tower.level + 1}`;
    ui.selectedTowerDescription.textContent = data.description || '';
    
    const canManage = !gameState.waveInProgress && !gameState.activityInProgress && !gameState.activityPreCountdown > 0;
    
    ui.moveButton.disabled = !canManage;
    ui.sellButton.disabled = !canManage;

    if (tower.level < data.costs.length - 1) {
        const upgradeCost = data.costs[tower.level + 1];
        ui.upgradeButton.textContent = `업글 (${upgradeCost}💰)`;
        ui.upgradeButton.disabled = !canManage || gameState.resources < upgradeCost;
    } else {
        ui.upgradeButton.textContent = '최대 레벨';
        ui.upgradeButton.disabled = true;
    }
    
    let totalCost = 0;
    for (let i = 0; i <= tower.level; i++) { totalCost += TOWER_DATA[tower.type].costs[i]; }
    ui.sellButton.textContent = `판매 (${totalCost}💰)`;

    ui.towerSelectionUI.classList.add('hidden');
    ui.towerManagementUI.classList.remove('hidden');
}

function showNotification(message, duration = 180) {
    gameState.notification = { message, timer: duration };
}

function handleCanvasClick(e) {
    if (gameState.gameOver || gameState.isPaused) return;

    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    let clickedSlot = null;
    for (const slot of gameState.towerSlots) {
        if (getDistance({x,y}, slot) < 20) {
            clickedSlot = slot;
            break;
        }
    }

    if (gameState.isMovingTower) {
        if (clickedSlot) {
            finalizeMoveTower(clickedSlot);
        } else {
            gameState.isMovingTower = false;
            gameState.towerToMove = null;
        }
        return;
    }

    if (clickedSlot) {
        handleSlotClick(clickedSlot);
    } else {
        let clickedOnTower = false;
        for (const tower of gameState.towers) {
            if (getDistance({x,y}, tower) < 20) {
                showTowerManagementUI(tower);
                clickedOnTower = true;
                break;
            }
        }
        if (!clickedOnTower) {
            showTowerSelectionUI();
        }
    }
}

function handleSlotClick(slot) {
    const isBuildPhase = !gameState.waveInProgress && !gameState.activityInProgress && !gameState.activityPreCountdown > 0;
    if (!isBuildPhase) return;

    if (slot.tower) {
        showTowerManagementUI(slot.tower);
        return;
    }

    const type = gameState.selectedTowerType;
    const data = TOWER_DATA[type];
    if (data.unlocked === false) {
        playSound('error');
        return;
    }
    const cost = data.costs[0];

    if (gameState.resources >= cost) {
        gameState.resources -= cost;
        const newTower = new Tower(slot, type);
        slot.tower = newTower;
        gameState.towers.push(newTower);
        playSound('build');
        updateUI();
    } else {
        playSound('error');
    }
}

// ==================================
// 사운드
// ==================================
function setupSound() {
    synth = new Tone.PolySynth(Tone.Synth, { oscillator: { type: "sine" }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.2, release: 0.2 } }).toDestination();
    hitSynth = new Tone.MembraneSynth({ pitchDecay: 0.05, octaves: 10, envelope: { attack: 0.001, decay: 0.4, sustain: 0.01, release: 0.5 } }).toDestination();
}

function playSound(type) {
    if (!synth) return;
    try {
        let time = Tone.now();
        if (time <= lastSoundTime) { time = lastSoundTime + soundOffset; }
        lastSoundTime = time;
        switch(type) {
            case 'shoot': synth.triggerAttackRelease("C5", "16n", time, 0.3); break;
            case 'hit': hitSynth.triggerAttackRelease("C2", "8n", time, 0.5); break;
            case 'build': synth.triggerAttackRelease("C4", "8n", time); break;
            case 'sell': synth.triggerAttackRelease("E3", "8n", time); break;
            case 'upgrade': synth.triggerAttackRelease(["C4", "E4", "G4"], "8n", time); break;
            case 'error': synth.triggerAttackRelease("F#3", "8n", time); break;
        }
    } catch(e) { console.error("Sound error", e); }
}

// ==================================
// 이벤트 리스너 설정
// ==================================
function setupEventListeners() {
    ui.modalButton.addEventListener('click', () => {
        ui.modal.style.display = 'none';
        if (!synth) {
            Tone.start().then(setupSound);
        }
        init();
    });

    canvas.addEventListener('click', handleCanvasClick);
    canvas.addEventListener('mousemove', e => {
        const rect = canvas.getBoundingClientRect();
        gameState.mousePos = { x: e.clientX - rect.left, y: e.clientY - rect.top };
    });

    ui.towerButtons.forEach(btn => {
        btn.addEventListener('click', () => {
            selectTowerType(btn.dataset.towerType);
            showTowerSelectionUI();
        });
    });

    ui.startWaveButton.addEventListener('click', startWave);

    ui.upgradeButton.addEventListener('click', () => {
        if (gameState.selectedTower && gameState.selectedTower.upgrade()) {
            showTowerManagementUI(gameState.selectedTower);
            updateUI();
        } else { playSound('error'); }
    });
    ui.sellButton.addEventListener('click', () => {
        if (gameState.selectedTower) {
            gameState.selectedTower.sell();
            showTowerSelectionUI();
            updateUI();
        }
    });
    ui.moveButton.addEventListener('click', initiateMoveTower);
    ui.closeManagementUI.addEventListener('click', showTowerSelectionUI);
    
    ui.tabButtons.forEach(button => {
        button.addEventListener('click', () => {
            const tabId = `panel-${button.dataset.tab}`;
            ui.tabButtons.forEach(btn => btn.classList.remove('active'));
            button.classList.add('active');
            ui.tabPanels.forEach(panel => panel.id === tabId ? panel.classList.remove('hidden') : panel.classList.add('hidden'));
            showTowerSelectionUI();
        });
    });
    
    ui.activityButtons.forEach(button => {
        button.addEventListener('click', () => startActivity(button.dataset.activity));
    });
    
    ui.giveUpActivityButton.addEventListener('click', giveUpActivity);
    
    ui.pauseButton.addEventListener('click', togglePause);
    ui.pauseModal.addEventListener('click', togglePause);
    
    ui.giveUpButton.addEventListener('click', () => {
        if (gameState.waveInProgress) {
            ui.confirmTitle.textContent = "웨이브 재시도";
            ui.confirmText.textContent = "현재 웨이브를 처음부터 다시 시작하시겠습니까?";
            confirmAction = retryWave;
            ui.confirmModal.style.display = 'flex';
        }
    });

    ui.confirmYesButton.addEventListener('click', () => {
        if (confirmAction) {
            confirmAction();
        }
        ui.confirmModal.style.display = 'none';
        confirmAction = null;
    });

    ui.confirmNoButton.addEventListener('click', () => {
        ui.confirmModal.style.display = 'none';
        confirmAction = null;
    });

    window.addEventListener('resize', () => {
        if (!gameState.gameOver) {
            ui.modalTitle.textContent = "화면 크기 변경됨";
            ui.modalText.textContent = "최적의 플레이를 위해 게임을 다시 시작합니다.";
            ui.modalButton.textContent = "확인";
            ui.modal.style.display = 'flex';
            if (gameState.animationFrameId) cancelAnimationFrame(gameState.animationFrameId);
        }
    });
}

// 게임 시작
setupEventListeners();

</script>
</body>
</html>
