<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>자기계발 타워 디펜스</title>
    <meta name="theme-color" content="#0c1427"/>
    <link rel="manifest" href="manifest.json">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Jua&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Jua', sans-serif;
            touch-action: none; /* 모바일에서 더블탭 확대 방지 */
            overflow: hidden;
            background-color: #0c1427;
        }
        /* 커스텀 스크롤바 */
        ::-webkit-scrollbar { width: 4px; }
        ::-webkit-scrollbar-track { background: #1e293b; }
        ::-webkit-scrollbar-thumb { background: #475569; border-radius: 2px; }

        .hud-item {
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(100, 116, 139, 0.5);
            transition: background-color 0.2s;
        }
        .tower-button.selected {
            background-color: #0e7490;
            box-shadow: 0 0 15px #06b6d4;
            transform: scale(1.05);
        }
        .tab-button.active {
            color: #06b6d4;
            border-color: #06b6d4;
        }
        .tower-button.locked .lock-overlay { display: flex; }
        .tower-button:not(.locked) .lock-overlay { display: none; }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .fade-in { animation: fadeIn 0.5s ease-out forwards; }
        
        @keyframes hurt-effect {
            0% { background-color: rgba(0, 0, 0, 0.4); transform: scale(1); }
            50% { background-color: rgba(220, 38, 38, 0.5); transform: scale(1.1); }
            100% { background-color: rgba(0, 0, 0, 0.4); transform: scale(1); }
        }
        .hurt {
            animation: hurt-effect 0.3s ease-out;
        }
    </style>
</head>
<body class="flex flex-col h-screen text-white p-2">

    <!-- 게임 UI 컨테이너 -->
    <div id="game-container" class="flex flex-col h-full w-full max-w-md mx-auto bg-[#16223b] rounded-xl shadow-2xl overflow-hidden border-2 border-slate-700 relative">

        <!-- 상단 HUD -->
        <div id="hud" class="grid grid-cols-3 gap-2 p-2 text-center">
            <div id="health-hud" class="hud-item rounded-lg p-2">
                <span class="text-xl">❤️</span>
                <span id="health" class="text-lg font-bold">100</span>
            </div>
            <div class="hud-item rounded-lg p-2">
                <span class="text-xl">💰</span>
                <span id="resources" class="text-lg font-bold">150</span>
            </div>
            <div class="hud-item rounded-lg p-2">
                <span class="text-xl">🌊</span>
                <span id="wave-info" class="text-lg font-bold">R1 0/10</span>
            </div>
        </div>
        
        <!-- 게임 캔버스 -->
        <div id="canvas-container" class="flex-1 relative">
            <canvas id="gameCanvas" class="absolute top-0 left-0 w-full h-full"></canvas>
        </div>

        <!-- 하단 컨트롤 패널 -->
        <div id="controls" class="p-2 bg-black bg-opacity-30 flex flex-col">
            <!-- 탭 버튼 -->
            <div class="flex mb-2 border-b border-slate-700">
                <button data-tab="build" class="tab-button flex-1 pb-2 text-lg font-bold border-b-2 transition-colors active">건설</button>
                <button data-tab="activity" class="tab-button flex-1 pb-2 text-lg font-bold border-b-2 border-transparent text-slate-400 transition-colors">활동</button>
            </div>
            
            <!-- 탭 패널 -->
            <div id="tab-panels" class="relative min-h-40">
                <!-- 건설/관리 패널 -->
                <div id="panel-build" class="tab-panel absolute inset-0 overflow-y-auto">
                    <div id="tower-selection-ui">
                        <div id="tower-buttons" class="grid grid-cols-3 gap-2">
                            <!-- JS로 동적 생성 -->
                        </div>
                    </div>
                    <div id="tower-management-ui" class="hidden">
                        <div id="management-buttons-container" class="grid grid-cols-3 gap-2">
                            <div id="selected-tower-info" class="col-span-3 text-center mb-2">
                                <p id="selected-tower-name" class="text-lg font-bold">타워 이름</p>
                                <p id="selected-tower-level" class="text-sm text-slate-400">레벨 1</p>
                                <p id="selected-tower-description" class="text-xs text-cyan-300 mt-1"></p>
                            </div>
                            <button id="upgrade-button" class="bg-blue-600 hover:bg-blue-500 rounded-lg p-3 font-bold transition-colors">업글</button>
                            <button id="skill-button" class="bg-purple-600 hover:bg-purple-500 rounded-lg p-3 font-bold transition-colors hidden">스킬</button>
                            <button id="sell-button" class="bg-red-700 hover:bg-red-600 rounded-lg p-3 font-bold transition-colors">판매</button>
                        </div>
                        <button id="close-management-ui" class="w-full mt-2 bg-slate-700 hover:bg-slate-600 rounded-lg p-2 text-sm">닫기</button>
                    </div>
                </div>
                
                <!-- 활동 패널 -->
                <div id="panel-activity" class="tab-panel absolute inset-0 hidden">
                    <p class="text-center text-sm text-slate-400 mb-2">활동을 완료하여 보상을 얻고 유닛을 해금하세요.</p>
                    <div id="activity-buttons-container" class="grid grid-cols-3 gap-2">
                         <button data-activity="study" class="activity-button flex flex-col items-center p-2 bg-slate-800 rounded-lg border border-slate-600 disabled:bg-slate-700 disabled:cursor-not-allowed">
                            <span class="text-3xl">📚</span>
                            <span class="font-bold">공부 (<span id="study-count">0</span>)</span>
                            <span class="text-xs text-slate-400">10초</span>
                        </button>
                        <button data-activity="exercise" class="activity-button flex flex-col items-center p-2 bg-slate-800 rounded-lg border border-slate-600 disabled:bg-slate-700 disabled:cursor-not-allowed">
                            <span class="text-3xl">🏋️</span>
                            <span class="font-bold">운동 (<span id="exercise-count">0</span>)</span>
                            <span class="text-xs text-slate-400">10초</span>
                        </button>
                        <button data-activity="read" class="activity-button flex flex-col items-center p-2 bg-slate-800 rounded-lg border border-slate-600 disabled:bg-slate-700 disabled:cursor-not-allowed">
                            <span class="text-3xl">📖</span>
                            <span class="font-bold">독서 (<span id="read-count">0</span>)</span>
                            <span class="text-xs text-slate-400">10초</span>
                        </button>
                    </div>
                    <button id="give-up-activity-button" class="hidden w-full mt-2 bg-red-800 hover:bg-red-700 rounded-lg p-3 font-bold transition-colors">활동 포기</button>
                </div>
            </div>
            
            <!-- 하단 고정 버튼 -->
            <div class="mt-2 grid grid-cols-1 gap-2">
                <button id="start-wave-button" class="w-full bg-green-600 hover:bg-green-500 rounded-lg p-3 text-xl font-bold transition-colors disabled:bg-slate-600 disabled:cursor-not-allowed">
                    웨이브 시작
                </button>
                <div class="grid grid-cols-2 gap-2 mt-2">
                    <button id="retry-wave-button" class="w-full p-2 bg-yellow-600 hover:bg-yellow-500 rounded-lg font-bold disabled:bg-slate-600 disabled:cursor-not-allowed">웨이브 재도전</button>
                    <button id="restart-game-button" class="w-full p-2 bg-red-800 hover:bg-red-700 rounded-lg font-bold">재시작</button>
                </div>
            </div>
        </div>

        <!-- 모달 -->
        <div id="modal" class="absolute inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 z-50">
            <div id="modal-content" class="bg-[#16223b] p-8 rounded-2xl shadow-lg text-center border-2 border-slate-600 max-w-sm w-full fade-in">
                <h2 id="modal-title" class="text-4xl font-bold mb-4 text-cyan-400">자기계발 디펜스</h2>
                <p id="modal-text" class="text-slate-300 mb-6">다가오는 적들로부터 코어를 지켜내세요! 활동으로 타워를 해금하고, 건설하여 승리하세요.</p>
                <button id="modal-button" class="w-full bg-cyan-600 hover:bg-cyan-500 rounded-lg p-4 text-xl font-bold transition-colors">게임 시작</button>
            </div>
        </div>

        <!-- 확인 모달 -->
        <div id="confirm-modal" class="hidden absolute inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 z-50">
            <div class="bg-[#16223b] p-8 rounded-2xl shadow-lg text-center border-2 border-slate-600 max-w-sm w-full fade-in">
                <h2 id="confirm-title" class="text-2xl font-bold mb-4 text-yellow-400">확인</h2>
                <p id="confirm-text" class="text-slate-300 mb-6"></p>
                <div class="flex gap-4">
                    <button id="confirm-yes-button" class="flex-1 bg-red-700 hover:bg-red-600 rounded-lg p-3 font-bold transition-colors">예</button>
                    <button id="confirm-no-button" class="flex-1 bg-slate-600 hover:bg-slate-500 rounded-lg p-3 font-bold transition-colors">아니오</button>
                </div>
            </div>
        </div>
    </div>

<script type="module">
// ==================================
// 게임 설정 (GameConfig.js)
// ==================================
const GameConfig = {
    // 라운드별 맵 설정
    maps: [
        { // Round 1
            path: [{x:0.5,y:0},{x:0.5,y:0.2},{x:0.8,y:0.2},{x:0.8,y:0.4},{x:0.2,y:0.4},{x:0.2,y:0.6},{x:0.8,y:0.6},{x:0.8,y:0.8},{x:0.5,y:0.8},{x:0.5,y:1}],
            slots: [{x:0.25,y:0.1},{x:0.75,y:0.1},{x:0.65,y:0.3},{x:0.95,y:0.3},{x:0.5,y:0.5},{x:0.05,y:0.5},{x:0.35,y:0.5},{x:0.65,y:0.9}]
        },
        { // Round 2
            path: [{x:0,y:0.5},{x:0.2,y:0.5},{x:0.2,y:0.2},{x:0.8,y:0.2},{x:0.8,y:0.8},{x:0.2,y:0.8},{x:0.2,y:0.5},{x:1,y:0.5}],
            slots: [{x:0.1,y:0.1},{x:0.4,y:0.1},{x:0.7,y:0.1},{x:0.1,y:0.35},{x:0.4,y:0.35},{x:0.7,y:0.35},{x:0.1,y:0.65},{x:0.4,y:0.65},{x:0.7,y:0.65}]
        },
        { // Round 3: Zigzag Canyon
            path: [{x:0.1,y:0},{x:0.1,y:0.2},{x:0.9,y:0.2},{x:0.9,y:0.4},{x:0.1,y:0.4},{x:0.1,y:0.6},{x:0.9,y:0.6},{x:0.9,y:0.8},{x:0.1,y:0.8},{x:0.1,y:1}],
            slots: [{x:0.5,y:0.1},{x:0.3,y:0.3},{x:0.7,y:0.3},{x:0.3,y:0.5},{x:0.7,y:0.5},{x:0.3,y:0.7},{x:0.7,y:0.7},{x:0.5,y:0.9}]
        },
        { // Round 4: Spiral Path
            path: [{x:0.5,y:0},{x:0.5,y:0.9},{x:0.1,y:0.9},{x:0.1,y:0.1},{x:0.9,y:0.1},{x:0.9,y:0.9},{x:0.5,y:0.9},{x:0.5,y:1}],
            slots: [{x:0.3,y:0.3},{x:0.7,y:0.3},{x:0.3,y:0.5},{x:0.5,y:0.5},{x:0.7,y:0.5},{x:0.3,y:0.7},{x:0.7,y:0.7}]
        },
        { // Round 5: Forked Road
            path: [{x:0.5,y:0},{x:0.5,y:0.2},{x:0.2,y:0.4},{x:0.2,y:0.6},{x:0.5,y:0.8},{x:0.5,y:1}],
            path2: [{x:0.5,y:0},{x:0.5,y:0.2},{x:0.8,y:0.4},{x:0.8,y:0.6},{x:0.5,y:0.8},{x:0.5,y:1}],
            slots: [{x:0.5,y:0.1},{x:0.2,y:0.25},{x:0.8,y:0.25},{x:0.5,y:0.35},{x:0.2,y:0.7},{x:0.8,y:0.7},{x:0.5,y:0.9}]
        }
    ],

    // 타워 데이터
    towers: {
        archer: { name: '궁수', icon: '🏹', costs: [20, 30, 45, 65, 90], damages: [6, 10, 15, 22, 30], ranges: [120, 125, 130, 135, 140], fireRates: [30, 28, 26, 24, 22], projectileType: 'arrow', description: '단일 적에게 빠른 화살을 발사합니다.', shortDesc: '단일 공격', unlocked: true },
        barracks: { name: '병영', icon: '🛡️', costs: [30, 45, 65, 90, 120], spawnRates: [400, 380, 360, 340, 320], maxSoldiers: [1, 1, 2, 2, 3], soldierHealth: [80, 110, 150, 200, 260], soldierDamage: [4, 7, 11, 16, 22], description: '경로를 막는 병사를 생성합니다.', shortDesc: '길목 방어', unlocked: true },
        ice: { name: '얼음', icon: '❄️', costs: [40, 55, 75, 100, 130], damages: [4, 6, 9, 13, 18], ranges: [100, 105, 110, 115, 120], fireRates: [90, 85, 80, 75, 70], projectileType: 'ice', effect: { type: 'slow', power: 0.5, duration: 120 }, description: '적을 2초간 50% 느리게 만듭니다.', shortDesc: '감속 효과', unlocked: true },
        
        // 활동 1회 해금 (광역)
        poisonSprayer: { name: '독구름 살포기', icon: '☠️', costs: [100, 130, 170, 220, 280], damages: [2.8, 4, 6.4, 8.8, 12.8], ranges: [100, 105, 110, 115, 120], fireRates: [120, 115, 110, 105, 100], projectileType: 'poison_bomb', description: '지속 피해를 주는 독구름 지역을 생성합니다.', shortDesc: '지속 독피해', unlockActivity: 'study', unlockCount: 1, unlocked: false },
        flamethrower: { name: '화염 방사탑', icon: '🔥', costs: [100, 130, 170, 220, 280], damages: [1, 1.5, 2, 2.8, 4], ranges: [80, 85, 90, 95, 100], fireRates: [5, 5, 5, 4, 4], attackAngle: Math.PI / 4, description: '부채꼴 범위에 지속적인 화염 피해를 줍니다.', shortDesc: '광역 화염', unlockActivity: 'exercise', unlockCount: 1, unlocked: false },
        holyBomber: { name: '신성한 폭격기', icon: '✨', costs: [100, 130, 170, 220, 280], damages: [26, 36, 50, 68, 90], ranges: [150, 155, 160, 165, 170], fireRates: [180, 170, 160, 150, 140], projectileType: 'holy_bomb', description: '체력이 높은 적에게 추가 피해를 주는 포탄을 떨어트립니다.', shortDesc: '탱크/보스 킬러', unlockActivity: 'read', unlockCount: 1, unlocked: false },

        // 활동 2회 해금 (전문 버프/디버프)
        laboratory: { name: '연구소', icon: '🔬', costs: [120], ranges: [100], effect: { type: 'damage_buff', value: 1.5 }, description: '주변 타워 공격력 +50%', shortDesc: '공격력 버프', unlockActivity: 'study', unlockCount: 2, unlocked: false },
        warDrums: { name: '전장의 북', icon: '🥁', costs: [120], ranges: [0], description: '액티브: 모든 병사 공속 +100%', shortDesc: '병사 공속', skill: { cost: 50, cooldown: 1800, duration: 480, effect: 'attack_speed_boost' }, unlockActivity: 'exercise', unlockCount: 2, unlocked: false },
        weaknessAnalyzer: { name: '약점 분석기', icon: '👁️', costs: [120], ranges: [100], effect: { type: 'debuff', value: 1.3 }, description: '주변 적이 받는 피해량 +30%', shortDesc: '피해 증폭', unlockActivity: 'read', unlockCount: 2, unlocked: false },
    },
    
    // 적 데이터
    enemies: {
        basic: { hp: 55, speed: 1.0, reward: 2, radius: 8, color: '#f87171', damage: 1 },
        fast: { hp: 30, speed: 1.8, reward: 3, radius: 7, color: '#fde047', damage: 1 },
        tank: { hp: 250, speed: 0.6, reward: 5, radius: 12, color: '#a1a1aa', damage: 2 },
        summonerBoss: { hp: 1000, speed: 0.7, reward: 100, radius: 20, color: '#a855f7', special: 'summon', summonCooldown: 600, summonType: 'fast', summonCount: 3, damage: 18 },
        juggernautBoss: { hp: 2100, speed: 0.6, reward: 150, radius: 22, color: '#7f1d1d', special: 'stun', stunCooldown: 480, stunRange: 120, stunDuration: 180, ignoresBlockers: true, damage: 18 },
        chaosLordBoss: { hp: 5000, speed: 0.5, reward: 500, radius: 25, color: '#4a044e', special: 'all', summonCooldown: 500, summonType: 'fast', summonCount: 4, stunCooldown: 400, stunRange: 130, stunDuration: 120, ignoresBlockers: true, damage: 18 },
    },
    
    // 웨이브 구성
    waveCompositionsByRound: [
        { // Round 1
            waves: [
                [['basic', 15, 50]], [['basic', 20, 45]], [['basic', 10, 40], ['fast', 5, 80]],
                [['fast', 15, 40]], [['basic', 15, 30], ['tank', 2, 200]], [['tank', 5, 120]],
                [['fast', 20, 30], ['tank', 3, 150]], [['basic', 20, 20], ['fast', 10, 40]],
                [['tank', 8, 100], ['fast', 10, 50]], [['summonerBoss', 1, 1]]
            ]
        },
        { // Round 2
            waves: [
                [['basic', 25, 35]], [['fast', 20, 25]], [['basic', 15, 30], ['tank', 3, 150]],
                [['tank', 8, 100]], [['fast', 25, 20]], [['basic', 20, 20], ['tank', 5, 120]],
                [['tank', 10, 80], ['fast', 10, 40]], [['fast', 30, 15]],
                [['basic', 20, 20], ['tank', 8, 100]], [['juggernautBoss', 1, 1]]
            ]
        },
        { // Round 3
            waves: [
                [['tank', 12, 90]], [['fast', 35, 18]], [['basic', 20, 20], ['tank', 8, 100]],
                [['tank', 12, 80], ['fast', 15, 30]], [['fast', 40, 15]],
                [['basic', 30, 15], ['tank', 10, 90]], [['tank', 15, 70]],
                [['fast', 20, 20], ['basic', 20, 20]], [['tank', 10, 60], ['fast', 20, 25]],
                [['summonerBoss', 2, 120]] // Enhanced boss
            ]
        },
        { // Round 4
            waves: [
                [['basic', 60, 9]], [['tank', 18, 55]], [['fast', 50, 10]],
                [['tank', 10, 50], ['fast', 20, 20]], [['basic', 40, 10], ['tank', 10, 50]],
                [['fast', 60, 10]], [['tank', 20, 40]],
                [['fast', 30, 15], ['tank', 10, 50]], [['basic', 50, 10]],
                [['juggernautBoss', 2, 120]] // Enhanced boss
            ]
        },
        { // Round 5
            waves: [
                [['tank', 25, 45]], [['fast', 70, 9]], [['basic', 40, 10], ['tank', 10, 50]],
                [['tank', 15, 40], ['fast', 30, 15]], [['fast', 70, 8]],
                [['tank', 25, 40]], [['basic', 30, 10], ['fast', 30, 10]],
                [['tank', 20, 40], ['fast', 20, 20]], [['basic', 60, 8]],
                [['chaosLordBoss', 1, 1]] // Final Boss
            ]
        }
    ],

    // 활동 데이터
    activities: {
        study: { name: '공부', duration: 10 * 60, reward: 100 },
        exercise: { name: '운동', duration: 10 * 60, reward: 100 },
        read: { name: '독서', duration: 10 * 60, reward: 100 },
    }
};

// ==================================
// 전역 변수 및 UI 요소
// ==================================
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const ui = {
    health: document.getElementById('health'),
    healthHud: document.getElementById('health-hud'),
    resources: document.getElementById('resources'),
    waveInfo: document.getElementById('wave-info'),
    towerButtonsContainer: document.getElementById('tower-buttons'),
    towerSelectionUI: document.getElementById('tower-selection-ui'),
    towerManagementUI: document.getElementById('tower-management-ui'),
    managementButtonsContainer: document.getElementById('management-buttons-container'),
    selectedTowerName: document.getElementById('selected-tower-name'),
    selectedTowerLevel: document.getElementById('selected-tower-level'),
    selectedTowerDescription: document.getElementById('selected-tower-description'),
    upgradeButton: document.getElementById('upgrade-button'),
    sellButton: document.getElementById('sell-button'),
    skillButton: document.getElementById('skill-button'),
    closeManagementUI: document.getElementById('close-management-ui'),
    startWaveButton: document.getElementById('start-wave-button'),
    retryWaveButton: document.getElementById('retry-wave-button'),
    restartGameButton: document.getElementById('restart-game-button'),
    tabButtons: document.querySelectorAll('.tab-button'),
    tabPanels: document.querySelectorAll('.tab-panel'),
    activityButtons: document.querySelectorAll('.activity-button'),
    giveUpActivityButton: document.getElementById('give-up-activity-button'),
    activityCounts: {
        study: document.getElementById('study-count'),
        exercise: document.getElementById('exercise-count'),
        read: document.getElementById('read-count'),
    },
    modal: document.getElementById('modal'),
    modalTitle: document.getElementById('modal-title'),
    modalText: document.getElementById('modal-text'),
    modalButton: document.getElementById('modal-button'),
    confirmModal: document.getElementById('confirm-modal'),
    confirmTitle: document.getElementById('confirm-title'),
    confirmText: document.getElementById('confirm-text'),
    confirmYesButton: document.getElementById('confirm-yes-button'),
    confirmNoButton: document.getElementById('confirm-no-button'),
};

let gameState = {};
let synth, hitSynth;
let confirmAction = null;
let lastSoundTime = 0;

// ==================================
// 클래스 정의
// ==================================
class Soldier {
    constructor(tower) {
        this.tower = tower;
        this.rallyPoint = tower.rallyPoint;
        this.x = this.rallyPoint.x + (Math.random() - 0.5) * 10;
        this.y = this.rallyPoint.y + (Math.random() - 0.5) * 10;
        
        const data = GameConfig.towers.barracks;
        this.health = data.soldierHealth[tower.level];
        this.maxHealth = this.health;
        this.damage = data.soldierDamage[tower.level];
        
        this.attackRange = 40;
        this.attackCooldown = 0;
        this.attackRate = 60;
        this.target = null;
        this.active = true;
        this.effects = [];
    }

    update() {
        if (!this.active || gameState.isPaused) return;
        
        this.effects.forEach((effect, index) => {
            effect.duration--;
            if (effect.duration <= 0) this.effects.splice(index, 1);
        });

        let currentAttackRate = this.attackRate;
        if (this.effects.find(e => e.type === 'attack_speed_boost')) {
            currentAttackRate /= 2; // 100% faster
        }

        this.attackCooldown--;
        if (!this.target || !this.target.active || getDistance(this, this.target) > this.attackRange) {
            this.findTarget();
        }

        if (this.target && this.attackCooldown <= 0) {
            this.target.takeDamage(this.damage);
            this.attackCooldown = currentAttackRate;
        }
    }

    findTarget() {
        this.target = null;
        let closestDist = this.attackRange;
        for (const enemy of gameState.enemies) {
            if (!enemy.active) continue;
            const dist = getDistance(this, enemy);
            if (dist < closestDist) {
                closestDist = dist;
                this.target = enemy;
            }
        }
    }

    draw() {
        ctx.fillStyle = this.effects.find(e => e.type === 'attack_speed_boost') ? '#f97316' : '#a1a1aa';
        ctx.beginPath();
        ctx.arc(this.x, this.y, 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#e4e4e7';
        ctx.lineWidth = 2;
        ctx.stroke();

        const healthBarWidth = 20;
        ctx.fillStyle = '#3f3f46';
        ctx.fillRect(this.x - healthBarWidth / 2, this.y - 15, healthBarWidth, 4);
        ctx.fillStyle = '#10b981';
        ctx.fillRect(this.x - healthBarWidth / 2, this.y - 15, healthBarWidth * (this.health / this.maxHealth), 4);
    }

    takeDamage(amount) {
        this.health -= amount;
        if (this.health <= 0) {
            this.active = false;
            const index = this.tower.soldiers.indexOf(this);
            if (index > -1) this.tower.soldiers.splice(index, 1);
        }
    }
    
    applyEffect(effect) {
        const existing = this.effects.find(e => e.type === effect.type);
        if (existing) existing.duration = Math.max(existing.duration, effect.duration);
        else this.effects.push({ ...effect });
    }
}

class Enemy {
    constructor(type, round, spawnOffset = {x: 0, y: 0}) {
        this.path = gameState.enemyPath;
        this.pathIndex = 0;
        const startPoint = this.path[0];
        this.x = startPoint.x + spawnOffset.x;
        this.y = startPoint.y + spawnOffset.y;
        
        const data = GameConfig.enemies[type];
        this.type = type;
        this.hp = data.hp * (1 + (round - 1) * 0.5);
        this.maxHp = this.hp;
        this.speed = data.speed;
        this.reward = data.reward;
        this.radius = data.radius;
        this.color = data.color;
        this.damage = data.damage || 1;
        this.active = true;
        this.effects = [];
        this.blockingSoldier = null;
        this.attackCooldown = 0;
        this.attackRate = 60;
        
        // Boss specific properties
        this.special = data.special;
        if (this.special === 'summon' || this.special === 'all') {
            this.summonCooldown = data.summonCooldown;
            this.summonTimer = this.summonCooldown;
            this.summonType = data.summonType;
            this.summonCount = data.summonCount;
        }
        if (this.special === 'stun' || this.special === 'all') {
            this.stunCooldown = data.stunCooldown;
            this.stunTimer = this.stunCooldown;
            this.stunRange = data.stunRange;
            this.stunDuration = data.stunDuration;
        }
        this.ignoresBlockers = data.ignoresBlockers || false;
    }
    update() {
        if (!this.active || gameState.isPaused) return;

        this.effects.forEach((effect, index) => {
            effect.duration--;
            if (effect.duration <= 0) this.effects.splice(index, 1);
        });
        
        this.attackCooldown--;

        if (this.blockingSoldier && !this.blockingSoldier.active) {
            this.blockingSoldier = null;
        }

        if (!this.blockingSoldier && !this.ignoresBlockers) {
            this.findBlockingSoldier();
        }

        if (this.blockingSoldier && !this.ignoresBlockers) {
            if (this.attackCooldown <= 0) {
                this.blockingSoldier.takeDamage(10);
                this.attackCooldown = this.attackRate;
            }
        } else {
            // Separation logic only when moving
            let separation = { x: 0, y: 0 };
            let count = 0;
            for (const other of gameState.enemies) {
                if (other === this) continue;
                const dist = getDistance(this, other);
                const combinedRadius = this.radius + other.radius;
                if (dist < combinedRadius && dist > 0) {
                    const diff = { x: this.x - other.x, y: this.y - other.y };
                    separation.x += diff.x / dist;
                    separation.y += diff.y / dist;
                    count++;
                }
            }
            if (count > 0) {
                this.x += (separation.x / count) * 0.5;
                this.y += (separation.y / count) * 0.5;
            }

            let currentSpeed = this.speed;
            if (this.effects.find(e => e.type === 'slow')) {
                currentSpeed *= (1 - GameConfig.towers.ice.effect.power);
            }

            if (this.pathIndex < this.path.length - 1) {
                const target = this.path[this.pathIndex + 1];
                const dx = target.x - this.x;
                const dy = target.y - this.y;
                const dist = Math.hypot(dx, dy);
                if (dist < currentSpeed) {
                    this.x = target.x;
                    this.y = target.y;
                    this.pathIndex++;
                } else {
                    this.x += (dx / dist) * currentSpeed;
                    this.y += (dy / dist) * currentSpeed;
                }
            } else {
                this.active = false;
                takeDamageToCore(this.damage);
            }
        }
        
        // Boss abilities
        if (this.special === 'summon' || this.special === 'all') {
            this.summonTimer--;
            if (this.summonTimer <= 0) {
                for (let i = 0; i < this.summonCount; i++) {
                    const offsetAngle = (i / this.summonCount) * Math.PI * 2;
                    const spawnOffset = { x: this.x + Math.cos(offsetAngle) * 30, y: this.y + Math.sin(offsetAngle) * 30 };
                    gameState.enemies.push(new Enemy(this.summonType, gameState.currentRound, spawnOffset));
                }
                this.summonTimer = this.hp < this.maxHp / 2 ? this.summonCooldown / 2 : this.summonCooldown;
            }
        }
        if (this.special === 'stun' || this.special === 'all') {
            this.stunTimer--;
            if (this.stunTimer <= 0) {
                gameState.towers.forEach(tower => {
                    if (getDistance(this, tower) <= this.stunRange) {
                        tower.stun(this.stunDuration);
                    }
                });
                this.stunTimer = this.stunCooldown;
            }
        }

        // Constrain enemy to path
        const closestPathPoint = findClosestPathPoint(this.x, this.y);
        const distFromPath = getDistance(this, closestPathPoint);
        const pathWidth = 15; // Half of the path width
        if (distFromPath > pathWidth) {
            const angleToPath = Math.atan2(closestPathPoint.y - this.y, closestPathPoint.x - this.x);
            this.x += Math.cos(angleToPath) * (distFromPath - pathWidth);
            this.y += Math.sin(angleToPath) * (distFromPath - pathWidth);
        }
    }

    findBlockingSoldier() {
        let closestDist = 25; 
        for (const soldier of gameState.soldiers) {
            if (getDistance(this, soldier) < closestDist) {
                this.blockingSoldier = soldier;
                break;
            }
        }
    }

    draw() {
        ctx.save();
        let isDebuffed = false;
        for (const tower of gameState.towers) {
            if (tower.type === 'weaknessAnalyzer' && getDistance(this, tower) <= tower.range) {
                isDebuffed = true;
                break;
            }
        }

        if (isDebuffed) {
            ctx.shadowColor = "magenta";
            ctx.shadowBlur = 15;
        }

        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        if (this.effects.find(e => e.type === 'slow')) {
            ctx.fillStyle = 'rgba(103, 232, 249, 0.5)';
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius * 1.2, 0, Math.PI * 2);
            ctx.fill();
        }
        
        if (this.effects.find(e => e.type === 'poison')) {
            ctx.fillStyle = 'rgba(132, 204, 22, 0.5)';
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fill();
        }

        const healthBarWidth = 25;
        ctx.fillStyle = '#3f3f46';
        ctx.fillRect(this.x - healthBarWidth / 2, this.y - this.radius - 8, healthBarWidth, 4);
        ctx.fillStyle = '#10b981';
        ctx.fillRect(this.x - healthBarWidth / 2, this.y - this.radius - 8, healthBarWidth * (this.hp / this.maxHp), 4);
    }
    takeDamage(amount, effect = null) {
        let finalDamage = amount;
        for (const tower of gameState.towers) {
            if (tower.type === 'weaknessAnalyzer' && getDistance(this, tower) <= tower.range) {
                finalDamage *= tower.effect.value;
                break;
            }
        }

        this.hp -= finalDamage;
        if (this.hp <= 0) {
            this.active = false;
            gameState.resources += this.reward;
            updateUI();
        }
        if (effect) {
            const existing = this.effects.find(e => e.type === effect.type);
            if (existing) existing.duration = Math.max(existing.duration, effect.duration);
            else this.effects.push({ ...effect });
        }
    }
}

class Tower {
    constructor(slot, type) {
        this.slot = slot;
        this.x = slot.x;
        this.y = slot.y;
        this.type = type;
        this.level = 0;
        this.target = null;
        this.fireCooldown = 0;
        this.skillCooldown = 0;
        this.direction = 0; // for flamethrower
        this.isStunned = false;
        this.stunTimer = 0;
        this.effects = [];
        this.setStats();

        if (this.type === 'barracks') {
            this.soldiers = [];
            this.spawnCooldown = 0;
            this.rallyPoint = findClosestPathPoint(this.x, this.y);
        }
    }
    setStats() {
        const data = GameConfig.towers[this.type];
        this.cost = data.costs[this.level];
        this.damage = data.damages ? data.damages[this.level] : 0;
        this.range = data.ranges ? data.ranges[this.level] : 0;
        this.fireRate = data.fireRates ? data.fireRates[this.level] : 0;
        if (data.spawnRates) {
            this.spawnRate = data.spawnRates[this.level];
            this.maxSoldiers = data.maxSoldiers[this.level];
            this.soldierHealth = data.soldierHealth[this.level];
            this.soldierDamage = data.soldierDamage[this.level];
        }
        if (data.effect) this.effect = data.effect;
        if (data.attackAngle) this.attackAngle = data.attackAngle;
        if (data.skill) this.skill = data.skill;
    }
    update() {
        if (gameState.isPaused) return;
        
        this.effects.forEach((effect, index) => {
            effect.duration--;
            if (effect.duration <= 0) this.effects.splice(index, 1);
        });
        
        if (this.isStunned) {
            this.stunTimer--;
            if (this.stunTimer <= 0) this.isStunned = false;
            return;
        }
        
        if(this.skillCooldown > 0) this.skillCooldown--;

        if (this.type === 'barracks') {
            this.spawnCooldown--;
            if (this.spawnCooldown <= 0 && this.soldiers.length < this.maxSoldiers) {
                const newSoldier = new Soldier(this);
                this.soldiers.push(newSoldier);
                gameState.soldiers.push(newSoldier);
                this.spawnCooldown = this.spawnRate;
            }
            return;
        }
        
        if (this.type === 'laboratory' || this.type === 'weaknessAnalyzer' || this.type === 'warDrums') {
            return; // Passive or skill-only towers
        }

        this.fireCooldown--;
        if (this.target && (!this.target.active || getDistance(this, this.target) > this.getRange())) {
            this.target = null;
        }
        if (!this.target) {
            this.findTarget();
        }
        
        if (this.target) {
            this.direction = Math.atan2(this.target.y - this.y, this.target.x - this.x);

            let currentFireRate = this.fireRate;
            if (this.effects.find(e => e.type === 'attack_speed_boost')) {
                currentFireRate /= 2;
            }

            if (this.fireCooldown <= 0) {
                this.fire();
                this.fireCooldown = currentFireRate;
            }
        }
    }
    
    getDamage() {
        let currentDamage = this.damage;
        gameState.towers.forEach(tower => {
            if (tower.type === 'laboratory' && getDistance(this, tower) <= tower.range + 20) {
                currentDamage *= tower.effect.value;
            }
        });
        return currentDamage;
    }

    getRange() { return this.range; }
    
    findTarget() {
        this.target = null;
        let closestDist = this.getRange();
        for (const enemy of gameState.enemies) {
            if (!enemy.active) continue;
            const dist = getDistance(this, enemy);
            if (dist < closestDist) {
                closestDist = dist;
                this.target = enemy;
            }
        }
    }
    
    fire() {
        if (!this.target) return;
        const data = GameConfig.towers[this.type];
        
        if (this.type === 'flamethrower') {
            for(let i = 0; i < 5; i++) {
                gameState.particles.push(new Particle(this.x, this.y, 'flame', this.direction, this.attackAngle));
            }
            gameState.enemies.forEach(enemy => {
                if (getDistance(this, enemy) < this.range) {
                    const angleToEnemy = Math.atan2(enemy.y - this.y, enemy.x - this.x);
                    let angleDiff = Math.abs(this.direction - angleToEnemy);
                    if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff;
                    if (angleDiff < this.attackAngle / 2) {
                        enemy.takeDamage(this.getDamage());
                    }
                }
            });
        } else {
            gameState.projectiles.push(new Projectile(this, this.target, this.getDamage(), data.projectileType, this.effect));
        }
        
        if (this.type !== 'flamethrower') {
            playSound('shoot');
        }
    }
    
    activateSkill() {
        if (!this.skill || this.skillCooldown > 0 || gameState.resources < this.skill.cost) {
            playSound('error');
            return;
        }
        gameState.resources -= this.skill.cost;
        this.skillCooldown = this.skill.cooldown;
        playSound('upgrade');

        if (this.skill.effect === 'attack_speed_boost') {
            gameState.soldiers.forEach(soldier => {
                soldier.applyEffect({ type: 'attack_speed_boost', duration: this.skill.duration });
            });
            gameState.towers.forEach(tower => {
                if (tower.damage > 0 || tower.type === 'flamethrower') {
                    tower.applyEffect({ type: 'attack_speed_boost', duration: this.skill.duration });
                }
            });
        }
        showTowerManagementUI(this);
    }

    stun(duration) {
        this.isStunned = true;
        this.stunTimer = duration;
    }

    applyEffect(effect) {
        const existing = this.effects.find(e => e.type === effect.type);
        if (existing) existing.duration = Math.max(existing.duration, effect.duration);
        else this.effects.push({ ...effect });
    }

    draw() {
        const data = GameConfig.towers[this.type];
        ctx.save();
        if (this.isStunned) {
            ctx.globalAlpha = 0.5;
        }
        
        if (this.effects.find(e => e.type === 'attack_speed_boost')) {
            ctx.fillStyle = 'rgba(249, 115, 22, 0.25)'; // Orange aura
            ctx.beginPath();
            ctx.arc(this.x, this.y, 25, 0, Math.PI * 2);
            ctx.fill();
        }

        // Draw buff aura for Laboratory
        if (this.type !== 'laboratory' && this.type !== 'barracks' && this.type !== 'warDrums' && this.type !== 'weaknessAnalyzer') {
            for (const tower of gameState.towers) {
                if (tower.type === 'laboratory' && getDistance(this, tower) <= tower.range + 20) {
                    ctx.fillStyle = 'rgba(253, 224, 71, 0.2)';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 25, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                }
            }
        }

        ctx.font = '24px Jua';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(data.icon, this.x, this.y);
        ctx.restore();

        ctx.fillStyle = 'white';
        ctx.font = '10px Jua';
        ctx.fillText(`Lv.${this.level + 1}`, this.x, this.y + 15);

        if (this.type === 'barracks' && this.rallyPoint) {
            ctx.strokeStyle = '#a1a1aa';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(this.x, this.y);
            ctx.lineTo(this.rallyPoint.x, this.rallyPoint.y);
            ctx.stroke();
            ctx.strokeRect(this.rallyPoint.x - 5, this.rallyPoint.y - 5, 10, 10);
        }

        if (gameState.selectedTower === this && this.range > 0) {
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.range, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        if (this.isStunned) {
            ctx.fillStyle = 'yellow';
            ctx.font = '12px Jua';
            ctx.fillText('⚡', this.x, this.y - 15);
        }
    }
    upgrade() {
        const data = GameConfig.towers[this.type];
        if (data.damages || data.spawnRates) { // Only allow upgrades for towers with scaling stats
            if (this.level < data.costs.length - 1) {
                const upgradeCost = data.costs[this.level + 1];
                if (gameState.resources >= upgradeCost) {
                    gameState.resources -= upgradeCost;
                    this.level++;
                    this.setStats();
                    playSound('upgrade');
                    return true;
                }
            }
        }
        return false;
    }
    sell() {
        let totalCost = 0;
        for (let i = 0; i <= this.level; i++) {
            totalCost += GameConfig.towers[this.type].costs[i];
        }
        gameState.resources += totalCost;
        this.slot.tower = null;
        if(this.type === 'barracks'){
            this.soldiers.forEach(s => s.active = false);
        }
        gameState.towers = gameState.towers.filter(t => t !== this);
        playSound('sell');
    }
}

class Projectile {
    constructor(source, target, damage, type, effect = null) {
        this.x = source.x;
        this.y = source.y;
        this.target = target;
        this.damage = damage;
        this.type = type;
        this.effect = effect;
        this.speed = 5;
        this.active = true;
        
        if(this.type === 'holy_bomb') {
            this.targetPos = {x: target.x, y: target.y};
        }
    }
    update() {
        if (!this.active || gameState.isPaused) return;

        let targetX, targetY;
        if (this.type === 'holy_bomb') {
            targetX = this.targetPos.x;
            targetY = this.targetPos.y;
        } else if (this.target && this.target.active) {
            targetX = this.target.x;
            targetY = this.target.y;
        } else {
            this.active = false;
            return;
        }

        const dx = targetX - this.x;
        const dy = targetY - this.y;
        const dist = Math.hypot(dx, dy);
        
        if (dist < this.speed) {
            this.active = false;
            playSound('hit');
            
            if(this.type === 'poison_bomb') {
                gameState.areaOfEffects.push(new AreaOfEffect(this.x, this.y, 40, 300, 'poison'));
            } else if (this.type === 'holy_bomb') {
                gameState.delayedBombs.push(new DelayedBomb(this.x, this.y, 50, 60, this.damage));
            } else {
                this.target.takeDamage(this.damage, this.effect);
            }
        } else {
            this.x += (dx / dist) * this.speed;
            this.y += (dy / dist) * this.speed;
        }
    }
    draw() {
        ctx.fillStyle = this.getColor();
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.type === 'holy_bomb' ? 8 : 4, 0, Math.PI * 2);
        ctx.fill();
    }
    getColor() {
        switch(this.type) {
            case 'arrow': return '#f59e0b';
            case 'ice': return '#67e8f9';
            case 'poison_bomb': return '#84cc16';
            case 'holy_bomb': return '#fef08a';
            default: return '#ffffff';
        }
    }
}

class Particle {
    constructor(x, y, type, direction, angle) {
        this.x = x; this.y = y; this.type = type;
        this.active = true;
        
        if (type === 'flame') {
            const spread = (Math.random() - 0.5) * angle;
            const speed = 1 + Math.random() * 2;
            this.vx = Math.cos(direction + spread) * speed;
            this.vy = Math.sin(direction + spread) * speed;
            this.life = 20 + Math.random() * 20;
            this.size = 2 + Math.random() * 3;
            this.color = `rgba(255, ${Math.floor(Math.random() * 150)}, 0, 1)`;
        }
    }
    update() {
        this.life--;
        if (this.life <= 0) this.active = false;
        this.x += this.vx;
        this.y += this.vy;
    }
    draw() {
        ctx.globalAlpha = this.life / 40;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
    }
}

class AreaOfEffect {
    constructor(x, y, radius, duration, type) {
        this.x = x; this.y = y; this.radius = radius;
        this.duration = duration; this.type = type;
        this.active = true;
        this.tickCooldown = 30; // 0.5초마다
        this.currentTick = 0;
    }
    update() {
        this.duration--;
        if (this.duration <= 0) this.active = false;
        
        this.currentTick--;
        if (this.currentTick <= 0) {
            gameState.enemies.forEach(enemy => {
                if (getDistance(this, enemy) < this.radius) {
                    if (this.type === 'poison') {
                        enemy.takeDamage(5); // 독 데미지
                    }
                }
            });
            this.currentTick = this.tickCooldown;
        }
    }
    draw() {
        const alpha = Math.min(1, this.duration / 300);
        if (this.type === 'poison') {
            ctx.fillStyle = `rgba(132, 204, 22, ${0.3 * alpha})`;
        }
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
    }
}

class DelayedBomb {
    constructor(x, y, radius, delay, damage) {
        this.x = x; this.y = y; this.radius = radius;
        this.timer = delay; this.damage = damage;
        this.active = true;
    }
    update() {
        this.timer--;
        if (this.timer <= 0) {
            this.active = false;
            playSound('hit'); // Explosion sound
            gameState.enemies.forEach(enemy => {
                if (getDistance(this, enemy) < this.radius) {
                    const percentageDamage = enemy.maxHp * 0.15;
                    const cappedPercentageDamage = Math.min(percentageDamage, 200);
                    const totalDamage = this.damage + cappedPercentageDamage;
                    enemy.takeDamage(totalDamage);
                }
            });
            for(let i = 0; i < 30; i++) {
                gameState.particles.push(new Particle(this.x, this.y, 'flame', Math.random() * Math.PI * 2, Math.PI * 2));
            }
        }
    }
    draw() {
        const progress = this.timer / 60;
        ctx.strokeStyle = `rgba(254, 240, 138, ${1 - progress})`;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius * (1 - progress), 0, Math.PI * 2);
        ctx.stroke();
    }
}

// ==================================
// 게임 초기화 및 흐름
// ==================================
function initGame() {
    if (gameState.animationFrameId) cancelAnimationFrame(gameState.animationFrameId);

    Object.values(GameConfig.towers).forEach(t => {
        if (t.unlockActivity) t.unlocked = false;
    });

    gameState = {
        health: 20,
        resources: 150,
        currentRound: 1,
        currentWave: 0,
        totalWavesPerRound: 10,
        towers: [],
        enemies: [],
        projectiles: [],
        soldiers: [],
        particles: [],
        areaOfEffects: [],
        delayedBombs: [],
        towerSlots: [],
        enemyPath: [],
        selectedTowerType: 'archer',
        selectedTower: null,
        waveInProgress: false,
        spawningComplete: false,
        gameOver: false,
        isPaused: false,
        activityInProgress: null,
        activityTimer: 0,
        completedActivities: { study: 0, exercise: 0, read: 0, total: 0 },
        timeoutIds: [],
        preWaveState: null,
    };
    
    loadRoundData();
    updateUI();
    updateTowerButtonsUI();
    selectTowerType('archer');
    showTowerSelectionUI();
    updateDynamicButtons();
    updateActivityCountUI();
    
    gameLoop();
}

function restartCurrentRound() {
    if (gameState.animationFrameId) cancelAnimationFrame(gameState.animationFrameId);

    const savedActivities = gameState.completedActivities;
    const savedUnlockedTowers = {};
    Object.entries(GameConfig.towers).forEach(([type, data]) => {
        if (data.unlocked) {
            savedUnlockedTowers[type] = true;
        }
    });

    const currentRound = gameState.currentRound;

    initGame(); // Start with a fresh state

    // Restore progress
    gameState.currentRound = currentRound;
    gameState.completedActivities = savedActivities;
    Object.entries(GameConfig.towers).forEach(([type, data]) => {
        if (savedUnlockedTowers[type]) {
            data.unlocked = true;
        }
    });

    // Reload data for the current round
    loadRoundData();
    updateUI();
    updateTowerButtonsUI();
    updateActivityCountUI();
}

function loadRoundData() {
    const roundIndex = gameState.currentRound - 1;
    if (roundIndex >= GameConfig.maps.length) {
        gameOver(true);
        return;
    }
    const mapData = GameConfig.maps[roundIndex];
    const container = document.getElementById('canvas-container');
    canvas.width = container.offsetWidth;
    canvas.height = container.offsetHeight;
    
    gameState.enemyPath = mapData.path.map(p => ({ x: p.x * canvas.width, y: p.y * canvas.height }));
    if (mapData.path2) {
        gameState.enemyPath2 = mapData.path2.map(p => ({ x: p.x * canvas.width, y: p.y * canvas.height }));
    } else {
        gameState.enemyPath2 = null;
    }

    gameState.towerSlots = mapData.slots.map(p => ({ x: p.x * canvas.width, y: p.y * canvas.height, tower: null }));
    gameState.towers = [];
    gameState.enemies = [];
    gameState.projectiles = [];
    gameState.soldiers = [];
    gameState.particles = [];
    gameState.areaOfEffects = [];
    gameState.delayedBombs = [];
}

function nextRound() {
    gameState.currentRound++;
    gameState.currentWave = 0;
    gameState.resources += 50; // Bonus for clearing a round
    loadRoundData();
    updateUI();
    showTowerSelectionUI();
    updateDynamicButtons();
}

function gameLoop() {
    if (gameState.gameOver) return;
    gameState.animationFrameId = requestAnimationFrame(gameLoop);
    if (gameState.isPaused) return;

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawPath();
    drawTowerSlots();

    if (gameState.activityInProgress) {
        gameState.activityTimer--;
        drawActivityTimer();
        if (gameState.activityTimer <= 0) completeActivity();
    }

    [...gameState.towers, ...gameState.soldiers, ...gameState.enemies, ...gameState.projectiles, ...gameState.particles, ...gameState.areaOfEffects, ...gameState.delayedBombs].forEach(e => e.update());

    gameState.areaOfEffects.forEach(e => e.draw());
    gameState.towers.forEach(e => e.draw());
    gameState.soldiers.sort((a, b) => a.y - b.y).forEach(e => e.draw());
    gameState.enemies.sort((a, b) => a.y - b.y).forEach(e => e.draw());
    gameState.projectiles.forEach(e => e.draw());
    gameState.delayedBombs.forEach(e => e.draw());
    gameState.particles.forEach(e => e.draw());

    gameState.enemies = gameState.enemies.filter(e => e.active);
    gameState.projectiles = gameState.projectiles.filter(e => e.active);
    gameState.soldiers = gameState.soldiers.filter(e => e.active);
    gameState.particles = gameState.particles.filter(e => e.active);
    gameState.areaOfEffects = gameState.areaOfEffects.filter(e => e.active);
    gameState.delayedBombs = gameState.delayedBombs.filter(e => e.active);

    if (gameState.waveInProgress && gameState.spawningComplete && gameState.enemies.length === 0) {
        endWave();
    }
}

function startWave() {
    if (gameState.waveInProgress || gameState.activityInProgress) return;
    
    gameState.preWaveState = {
        health: gameState.health,
        resources: gameState.resources,
        towers: gameState.towers.map(t => ({
            type: t.type,
            level: t.level,
            slotIndex: gameState.towerSlots.indexOf(t.slot)
        })),
    };

    gameState.waveInProgress = true;
    gameState.spawningComplete = false;
    gameState.currentWave++;
    
    updateDynamicButtons();
    updateUI();
    
    const roundWaves = GameConfig.waveCompositionsByRound[gameState.currentRound - 1];
    let waveComposition = roundWaves.waves[gameState.currentWave - 1];
    
    let totalSpawnTime = 0;
    
    waveComposition.forEach(([type, count, interval]) => {
        for (let i = 0; i < count; i++) {
            const spawnTime = i * interval;
            const timeoutId = setTimeout(() => {
                if (!gameState.gameOver) {
                    const spawnOffset = { x: (Math.random() - 0.5) * 15, y: (Math.random() - 0.5) * 15 };
                    gameState.enemies.push(new Enemy(type, gameState.currentRound, spawnOffset));
                }
            }, spawnTime);
            gameState.timeoutIds.push(timeoutId);
            if(spawnTime > totalSpawnTime) totalSpawnTime = spawnTime;
        }
    });

    const completionTimeoutId = setTimeout(() => {
        if (!gameState.gameOver) gameState.spawningComplete = true;
    }, totalSpawnTime + 1);
    gameState.timeoutIds.push(completionTimeoutId);
}

function endWave() {
    gameState.waveInProgress = false;
    gameState.spawningComplete = false;
    gameState.timeoutIds.forEach(clearTimeout);
    gameState.timeoutIds = [];
    updateDynamicButtons();

    if (gameState.currentWave >= gameState.totalWavesPerRound) {
        const isLastRound = gameState.currentRound >= GameConfig.maps.length;
        ui.modalTitle.textContent = isLastRound ? "🎉 최종 승리! 🎉" : `라운드 ${gameState.currentRound} 클리어!`;
        ui.modalText.textContent = isLastRound ? "모든 라운드를 클리어했습니다!" : "다음 라운드로 도전하세요.";
        ui.modalButton.textContent = isLastRound ? "다시 시작" : "다음 라운드";
        confirmAction = isLastRound ? initGame : nextRound;
        ui.modal.style.display = 'flex';
    }
    updateUI();
}

function gameOver(isVictory) {
    if (gameState.gameOver) return;
    gameState.gameOver = true;
    cancelAnimationFrame(gameState.animationFrameId);
    gameState.timeoutIds.forEach(clearTimeout);
    
    ui.modalTitle.textContent = isVictory ? "🎉 최종 승리! 🎉" : "게임 오버";
    ui.modalText.textContent = isVictory ? "모든 적을 막아냈습니다!" : `코어가 파괴되었습니다. (라운드 ${gameState.currentRound} - 웨이브 ${gameState.currentWave})`;
    ui.modalButton.textContent = "다시 시작";
    confirmAction = initGame;
    ui.modal.style.display = 'flex';
}

function retryWave() {
    if (!gameState.preWaveState) {
        playSound('error');
        return;
    };

    gameState.timeoutIds.forEach(id => clearTimeout(id));
    gameState.timeoutIds = [];
    
    const snapshot = gameState.preWaveState;
    gameState.health = snapshot.health;
    gameState.resources = snapshot.resources;
    gameState.currentWave--; 

    // Clear current dynamic entities
    gameState.enemies = [];
    gameState.projectiles = [];
    gameState.particles = [];
    gameState.soldiers = [];
    gameState.areaOfEffects = [];
    gameState.delayedBombs = [];

    // Rebuild towers from snapshot
    gameState.towerSlots.forEach(slot => slot.tower = null);
    gameState.towers = [];
    snapshot.towers.forEach(towerData => {
        const slot = gameState.towerSlots[towerData.slotIndex];
        if (slot) {
            const newTower = new Tower(slot, towerData.type);
            newTower.level = towerData.level;
            newTower.setStats();
            slot.tower = newTower;
            gameState.towers.push(newTower);
        }
    });

    gameState.waveInProgress = false;
    gameState.spawningComplete = false;
    gameState.preWaveState = null;

    updateUI();
    updateDynamicButtons();
    showTowerSelectionUI();
    playSound('sell');
}

// ==================================
// 유틸리티 및 헬퍼 함수
// ==================================
function getDistance(obj1, obj2) { return Math.hypot(obj1.x - obj2.x, obj1.y - obj2.y); }

function findClosestPathPoint(x, y) {
    let closestPoint = null;
    let minDistance = Infinity;

    for (let i = 0; i < gameState.enemyPath.length - 1; i++) {
        const p1 = gameState.enemyPath[i];
        const p2 = gameState.enemyPath[i + 1];
        
        const lenSq = (p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2;
        if (lenSq === 0) continue;

        let t = ((x - p1.x) * (p2.x - p1.x) + (y - p1.y) * (p2.y - p1.y)) / lenSq;
        t = Math.max(0, Math.min(1, t));

        const closest = { x: p1.x + t * (p2.x - p1.x), y: p1.y + t * (p2.y - p1.y) };
        const distSq = (x - closest.x) ** 2 + (y - closest.y) ** 2;

        if (distSq < minDistance) {
            minDistance = distSq;
            closestPoint = closest;
        }
    }
    return closestPoint;
}

function takeDamageToCore(damage) {
    gameState.health -= damage;
    if (gameState.health < 0) gameState.health = 0;
    updateUI();

    ui.healthHud.classList.remove('hurt');
    void ui.healthHud.offsetWidth; // Trigger reflow to restart animation
    ui.healthHud.classList.add('hurt');

    if (gameState.health <= 0 && !gameState.gameOver) {
        gameOver(false);
    }
}

// ==================================
// UI 및 이벤트 처리
// ==================================
function updateUI() {
    ui.health.textContent = gameState.health;
    ui.resources.textContent = gameState.resources;
    ui.waveInfo.textContent = `R${gameState.currentRound} ${gameState.currentWave}/${gameState.totalWavesPerRound}`;
    ui.startWaveButton.textContent = gameState.waveInProgress ? `웨이브 ${gameState.currentWave} 진행 중` : `웨이브 ${gameState.currentWave + 1} 시작`;
}

function updateTowerButtonsUI() {
    ui.towerButtonsContainer.innerHTML = '';
    const towerOrder = [
        'archer', 'barracks', 'ice',
        'poisonSprayer', 'flamethrower', 'holyBomber',
        'laboratory', 'warDrums', 'weaknessAnalyzer'
    ];

    towerOrder.forEach(type => {
        const data = GameConfig.towers[type];
        if (!data) return;

        const button = document.createElement('button');
        button.dataset.towerType = type;
        button.className = 'tower-button flex flex-col items-center justify-between p-1 rounded-lg border transition-all duration-200 relative h-24';
        
        const isUnlocked = data.unlocked;
        
        let descriptionText = '';
        if (isUnlocked) {
            descriptionText = data.shortDesc;
        } else {
            const activityName = data.unlockActivity === 'study' ? '공부' : data.unlockActivity === 'exercise' ? '운동' : '독서';
            descriptionText = `${activityName} ${data.unlockCount || 1}회`;
        }

        button.innerHTML = `
            <div class="flex flex-col items-center text-center">
                <span class="text-2xl ${!isUnlocked ? 'opacity-30' : ''}">${data.icon}</span>
                <span class="font-bold text-xs leading-tight ${!isUnlocked ? 'text-slate-500' : ''}">${data.name}</span>
            </div>
            <div class="text-center">
                <span class="text-cyan-400 text-[10px] leading-tight">${descriptionText}</span>
                <span class="text-yellow-400 text-xs block">${data.costs[0]}💰</span>
            </div>
            <div class="lock-overlay absolute inset-0 items-center justify-center bg-black bg-opacity-60 rounded-lg"><span class="text-2xl">🔒</span></div>
        `;

        if (isUnlocked) {
            button.classList.add('bg-slate-800', 'border-slate-600');
        } else {
            button.classList.add('locked', 'bg-slate-900', 'border-slate-700');
            button.disabled = true;
        }
        
        button.addEventListener('click', () => {
            selectTowerType(type);
            showTowerSelectionUI();
        });
        ui.towerButtonsContainer.appendChild(button);
    });
}

function updateDynamicButtons() {
    const isBuildPhase = !gameState.waveInProgress && !gameState.activityInProgress;
    ui.startWaveButton.disabled = !isBuildPhase;
    ui.retryWaveButton.disabled = !gameState.waveInProgress;
    ui.activityButtons.forEach(btn => btn.disabled = !isBuildPhase);
    ui.giveUpActivityButton.classList.toggle('hidden', !gameState.activityInProgress);
}

function selectTowerType(type) {
    gameState.selectedTowerType = type;
    document.querySelectorAll('.tower-button').forEach(btn => {
        btn.classList.toggle('selected', btn.dataset.towerType === type);
    });
}

function showTowerSelectionUI() {
    gameState.selectedTower = null;
    ui.towerManagementUI.classList.add('hidden');
    ui.towerSelectionUI.classList.remove('hidden');
}

function showTowerManagementUI(tower) {
    gameState.selectedTower = tower;
    const data = GameConfig.towers[tower.type];
    ui.selectedTowerName.textContent = data.name;
    ui.selectedTowerLevel.textContent = `레벨 ${tower.level + 1}`;
    ui.selectedTowerDescription.textContent = data.description || '';
    
    const canManage = !gameState.waveInProgress && !gameState.activityInProgress;
    
    const upgradeButton = ui.upgradeButton;
    const sellButton = ui.sellButton;
    const skillButton = ui.skillButton;

    if (tower.skill) {
        skillButton.classList.remove('hidden');
        upgradeButton.className = sellButton.className = "col-span-1 bg-blue-600 hover:bg-blue-500 rounded-lg p-3 font-bold transition-colors";
        sellButton.classList.replace('bg-blue-600', 'bg-red-700');
        sellButton.classList.replace('hover:bg-blue-500', 'hover:bg-red-600');
        
        if (tower.skillCooldown > 0) {
            skillButton.textContent = `쿨 (${Math.ceil(tower.skillCooldown / 60)}초)`;
            skillButton.disabled = true;
        } else {
            skillButton.textContent = `스킬 (${tower.skill.cost}💰)`;
            skillButton.disabled = gameState.resources < tower.skill.cost;
        }
    } else {
        skillButton.classList.add('hidden');
        upgradeButton.className = "col-span-2 bg-blue-600 hover:bg-blue-500 rounded-lg p-3 font-bold transition-colors";
        sellButton.className = "col-span-1 bg-red-700 hover:bg-red-600 rounded-lg p-3 font-bold transition-colors";
    }

    const isUpgradable = data.damages || data.spawnRates;
    if (!isUpgradable) {
        upgradeButton.disabled = true;
        upgradeButton.textContent = '업그레이드 불가';
    } else {
        upgradeButton.disabled = !canManage || tower.level >= data.costs.length - 1;
        if (tower.level < data.costs.length - 1) {
            const upgradeCost = data.costs[tower.level + 1];
            upgradeButton.textContent = `업글 (${upgradeCost}💰)`;
            upgradeButton.disabled = !canManage || gameState.resources < upgradeCost;
        } else {
            upgradeButton.textContent = '최대 레벨';
            upgradeButton.disabled = true;
        }
    }
    
    sellButton.disabled = !canManage;
    
    let totalCost = 0;
    for (let i = 0; i <= tower.level; i++) { totalCost += data.costs[i]; }
    sellButton.textContent = `판매`;
    
    ui.towerSelectionUI.classList.add('hidden');
    ui.towerManagementUI.classList.remove('hidden');
}

function handleCanvasClick(e) {
    if (gameState.gameOver || gameState.isPaused) return;

    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    for (const tower of gameState.towers) {
        if (getDistance({x,y}, tower) < 20) {
            showTowerManagementUI(tower);
            return;
        }
    }

    let clickedSlot = null;
    for (const slot of gameState.towerSlots) {
        if (getDistance({x,y}, slot) < 20) {
            clickedSlot = slot;
            break;
        }
    }
    
    if (clickedSlot) handleSlotClick(clickedSlot);
    else showTowerSelectionUI();
}

function handleSlotClick(slot) {
    if (gameState.waveInProgress || gameState.activityInProgress || slot.tower) return;

    const type = gameState.selectedTowerType;
    const data = GameConfig.towers[type];
    if (!data.unlocked) { playSound('error'); return; }
    const cost = data.costs[0];

    if (gameState.resources >= cost) {
        gameState.resources -= cost;
        const newTower = new Tower(slot, type);
        slot.tower = newTower;
        gameState.towers.push(newTower);
        playSound('build');
        updateUI();
    } else {
        playSound('error');
    }
}

// ==================================
// 활동 관련 함수
// ==================================
function startActivity(type) {
    if (gameState.waveInProgress || gameState.activityInProgress) return;
    gameState.activityInProgress = type;
    gameState.activityTimer = GameConfig.activities[type].duration;
    updateDynamicButtons();
    playSound('upgrade');
}

function completeActivity() {
    const type = gameState.activityInProgress;
    gameState.resources += GameConfig.activities[type].reward;
    gameState.completedActivities[type]++;
    gameState.completedActivities.total++;
    checkUnlocks();
    
    gameState.activityInProgress = null;
    gameState.activityTimer = 0;
    updateUI();
    updateDynamicButtons();
    updateActivityCountUI();
    playSound('upgrade');
}

function giveUpActivity() {
    if (!gameState.activityInProgress) return;
    gameState.activityInProgress = null;
    gameState.activityTimer = 0;
    playSound('sell');
    updateDynamicButtons();
}

function checkUnlocks() {
    Object.entries(GameConfig.towers).forEach(([type, data]) => {
        if (!data.unlocked && data.unlockActivity) {
            if (gameState.completedActivities[data.unlockActivity] >= data.unlockCount) {
                data.unlocked = true;
                updateTowerButtonsUI();
            }
        }
    });
}

function updateActivityCountUI() {
    ui.activityCounts.study.textContent = gameState.completedActivities.study;
    ui.activityCounts.exercise.textContent = gameState.completedActivities.exercise;
    ui.activityCounts.read.textContent = gameState.completedActivities.read;
}

function drawActivityTimer() {
    const type = gameState.activityInProgress;
    const duration = GameConfig.activities[type].duration;
    const progress = 1 - (gameState.activityTimer / duration);
    const barWidth = canvas.width * 0.8;
    const barX = (canvas.width - barWidth) / 2;
    
    ctx.fillStyle = "rgba(0,0,0,0.5)";
    ctx.fillRect(barX, 20, barWidth, 30);
    ctx.fillStyle = "#22c55e";
    ctx.fillRect(barX, 20, barWidth * progress, 30);
    
    const totalSeconds = Math.ceil(gameState.activityTimer / 60);
    const timeString = `${String(totalSeconds).padStart(2, '0')}초`;

    ctx.fillStyle = "white";
    ctx.font = "16px Jua";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(`${GameConfig.activities[type].name} 중... ${timeString}`, canvas.width / 2, 35);
}

// ==================================
// 사운드
// ==================================
function setupSound() {
    synth = new Tone.PolySynth(Tone.Synth, { oscillator: { type: "sine" }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.2, release: 0.2 } }).toDestination();
    hitSynth = new Tone.MembraneSynth({ pitchDecay: 0.05, octaves: 10, envelope: { attack: 0.001, decay: 0.4, sustain: 0.01, release: 0.5 } }).toDestination();
}

function playSound(type) {
    if (!synth) return;
    try {
        let scheduledTime = Tone.now();
        if (scheduledTime <= lastSoundTime) {
            scheduledTime = lastSoundTime + 0.01;
        }
        lastSoundTime = scheduledTime;

        switch(type) {
            case 'shoot': synth.triggerAttackRelease("C5", "16n", scheduledTime, 0.3); break;
            case 'hit': hitSynth.triggerAttackRelease("C2", "8n", scheduledTime, 0.5); break;
            case 'build': synth.triggerAttackRelease("C4", "8n", scheduledTime); break;
            case 'sell': synth.triggerAttackRelease("E3", "8n", scheduledTime); break;
            case 'upgrade': synth.triggerAttackRelease(["C4", "E4", "G4"], "8n", scheduledTime); break;
            case 'error': synth.triggerAttackRelease("F#3", "8n", scheduledTime); break;
        }
    } catch(e) { console.error("Sound error", e); }
}

// ==================================
// 이벤트 리스너 설정
// ==================================
function setupEventListeners() {
    ui.modalButton.addEventListener('click', () => {
        ui.modal.style.display = 'none';
        if (!synth) Tone.start().then(setupSound);
        if (confirmAction) confirmAction();
    });

    canvas.addEventListener('click', handleCanvasClick);
    ui.startWaveButton.addEventListener('click', startWave);
    ui.upgradeButton.addEventListener('click', () => {
        if (gameState.selectedTower && gameState.selectedTower.upgrade()) {
            showTowerManagementUI(gameState.selectedTower);
            updateUI();
        } else { playSound('error'); }
    });
    ui.sellButton.addEventListener('click', () => {
        if (gameState.selectedTower) {
            gameState.selectedTower.sell();
            showTowerSelectionUI();
            updateUI();
        }
    });
    ui.skillButton.addEventListener('click', () => {
        if (gameState.selectedTower) {
            gameState.selectedTower.activateSkill();
        }
    });
    ui.closeManagementUI.addEventListener('click', showTowerSelectionUI);
    
    ui.tabButtons.forEach(button => {
        button.addEventListener('click', () => {
            const tabId = `panel-${button.dataset.tab}`;
            ui.tabButtons.forEach(btn => btn.classList.remove('active', 'text-cyan-400', 'border-cyan-400'));
            ui.tabButtons.forEach(btn => btn.classList.add('text-slate-400', 'border-transparent'));
            button.classList.add('active', 'text-cyan-400', 'border-cyan-400');
            button.classList.remove('text-slate-400', 'border-transparent');
            ui.tabPanels.forEach(panel => panel.id === tabId ? panel.classList.remove('hidden') : panel.classList.add('hidden'));
            showTowerSelectionUI();
        });
    });
    
    ui.activityButtons.forEach(button => {
        button.addEventListener('click', () => startActivity(button.dataset.activity));
    });
    
    ui.giveUpActivityButton.addEventListener('click', giveUpActivity);
    
    ui.retryWaveButton.addEventListener('click', () => {
        if(gameState.waveInProgress) {
            ui.confirmTitle.textContent = "웨이브 재도전";
            ui.confirmText.textContent = "현재 웨이브를 다시 시작하시겠습니까?";
            confirmAction = retryWave;
            ui.confirmModal.style.display = 'flex';
        }
    });

    ui.restartGameButton.addEventListener('click', () => {
        if (gameState.currentRound > 1) {
            ui.confirmTitle.textContent = "라운드 재시작";
            ui.confirmText.textContent = `현재 라운드(${gameState.currentRound})를 처음부터 다시 시작하시겠습니까? (해금된 유닛은 유지됩니다)`;
            confirmAction = restartCurrentRound;
        } else {
            ui.confirmTitle.textContent = "게임 재시작";
            ui.confirmText.textContent = "정말로 게임을 처음부터 다시 시작하시겠습니까?";
            confirmAction = initGame;
        }
        ui.confirmModal.style.display = 'flex';
    });

    ui.confirmYesButton.addEventListener('click', () => {
        if (confirmAction) confirmAction();
        ui.confirmModal.style.display = 'none';
    });

    ui.confirmNoButton.addEventListener('click', () => {
        ui.confirmModal.style.display = 'none';
    });

    // 초기 모달 설정
    ui.modalTitle.textContent = "자기계발 디펜스";
    ui.modalText.textContent = "다가오는 적들로부터 코어를 지켜내세요! 활동으로 타워를 해금하고, 건설하여 승리하세요.";
    ui.modalButton.textContent = "게임 시작";
    confirmAction = initGame;
    ui.modal.style.display = 'flex';
}

function drawPath() {
    ctx.strokeStyle = 'rgba(100, 116, 139, 0.4)';
    ctx.lineWidth = 30;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(gameState.enemyPath[0].x, gameState.enemyPath[0].y);
    for (let i = 1; i < gameState.enemyPath.length; i++) {
        ctx.lineTo(gameState.enemyPath[i].x, gameState.enemyPath[i].y);
    }
    ctx.stroke();

    if (gameState.enemyPath2) {
        ctx.beginPath();
        ctx.moveTo(gameState.enemyPath2[0].x, gameState.enemyPath2[0].y);
        for (let i = 1; i < gameState.enemyPath2.length; i++) {
            ctx.lineTo(gameState.enemyPath2[i].x, gameState.enemyPath2[i].y);
        }
        ctx.stroke();
    }
}

function drawTowerSlots() {
    gameState.towerSlots.forEach((slot) => {
        ctx.fillStyle = slot.tower ? 'rgba(56, 189, 248, 0.1)' : 'rgba(255, 255, 255, 0.05)';
        ctx.strokeStyle = 'rgba(100, 116, 139, 0.7)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(slot.x, slot.y, 20, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
    });
}

// 게임 시작
setupEventListeners();

</script>
</body>
</html>
```

```json
{
  "name": "자기계발 타워 디펜스",
  "short_name": "자기계발 디펜스",
  "start_url": ".",
  "display": "fullscreen",
  "background_color": "#0c1427",
  "theme_color": "#0c1427",
  "description": "활동으로 강해지는 타워 디펜스 게임",
  "icons": [
    {
      "src": "https://placehold.co/192x192/0c1427/FFFFFF?text=TD",
      "sizes": "192x192",
      "type": "image/png"
    },
    {
      "src": "https://placehold.co/512x512/0c1427/FFFFFF?text=TD",
      "sizes": "512x512",
      "type": "image/png"
    }
  ]
}
